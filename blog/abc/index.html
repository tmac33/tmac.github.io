<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="author"
    content="">
<meta name="description"
    content="为什么使用abstract base classes? 抽象基类是一种比hasattr()检查特定方法更严格的接口检查形式。通过定义抽象基类，就可以为一组字类建立公共API。
How ABCs Work? abc将基础类方法标记为抽象，然后将具体类注册为抽象类的实现。
# abc_base.py import abc class PluginBase(metaclass=abc.ABCMeta): @abc.abstractmethod def load(self, input): &amp;quot;&amp;quot;&amp;quot;Retrieve data from the input source and return an object. &amp;quot;&amp;quot;&amp;quot; @abc.abstractmethod def save(self, output, data): &amp;quot;&amp;quot;&amp;quot;Save the data object to the output.&amp;quot;&amp;quot;&amp;quot;  注册一个具体的类 # abc_register.py import abc from abc_base import PluginBase class LocalBaseClass: pass @PluginBase.register class RegisteredImplementation(LocalBaseClass): def load(self, input): return input.read() def save(self, output, data): return output.write(data) if __name__ == &#39;__main__&#39;: print(&#39;Subclass:&#39;, issubclass(RegisteredImplementation, PluginBase)) print(&#39;Instance:&#39;, isinstance(RegisteredImplementation(), PluginBase))  $ python3 abc_register." />
<meta name="keywords" content="Golang&amp;.Net Core" />
<meta name="robots" content="noodp" />
<link rel="canonical" href="/blog/abc/" />


<title>
    
    python中的abc module :: Code and Things  — Cosmo Wu
    
</title>



<link href="https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.2.1/css/flag-icon.min.css" rel="stylesheet"
    type="text/css">



<link rel="stylesheet" href="/main.min.91687bbfc139d7ff1a244bb6d7324425f9c4f424eaaad242b478e3b3cf56396a.css">



<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#252627">
<link rel="shortcut icon" href="/favicon.ico">
<meta name="theme-color" content="#252627">
<meta itemprop="name" content="python中的abc module">
<meta itemprop="description" content="为什么使用abstract base classes? 抽象基类是一种比hasattr()检查特定方法更严格的接口检查形式。通过定义抽象基类，就可以为一组字类建立公共API。
How ABCs Work? abc将基础类方法标记为抽象，然后将具体类注册为抽象类的实现。
# abc_base.py import abc class PluginBase(metaclass=abc.ABCMeta): @abc.abstractmethod def load(self, input): &quot;&quot;&quot;Retrieve data from the input source and return an object. &quot;&quot;&quot; @abc.abstractmethod def save(self, output, data): &quot;&quot;&quot;Save the data object to the output.&quot;&quot;&quot;  注册一个具体的类 # abc_register.py import abc from abc_base import PluginBase class LocalBaseClass: pass @PluginBase.register class RegisteredImplementation(LocalBaseClass): def load(self, input): return input.read() def save(self, output, data): return output.write(data) if __name__ == &#39;__main__&#39;: print(&#39;Subclass:&#39;, issubclass(RegisteredImplementation, PluginBase)) print(&#39;Instance:&#39;, isinstance(RegisteredImplementation(), PluginBase))  $ python3 abc_register.">


<meta itemprop="datePublished" content="2020-01-18T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2020-01-18T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="744">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="/"/>

<meta name="twitter:title" content="python中的abc module"/>
<meta name="twitter:description" content="为什么使用abstract base classes? 抽象基类是一种比hasattr()检查特定方法更严格的接口检查形式。通过定义抽象基类，就可以为一组字类建立公共API。
How ABCs Work? abc将基础类方法标记为抽象，然后将具体类注册为抽象类的实现。
# abc_base.py import abc class PluginBase(metaclass=abc.ABCMeta): @abc.abstractmethod def load(self, input): &quot;&quot;&quot;Retrieve data from the input source and return an object. &quot;&quot;&quot; @abc.abstractmethod def save(self, output, data): &quot;&quot;&quot;Save the data object to the output.&quot;&quot;&quot;  注册一个具体的类 # abc_register.py import abc from abc_base import PluginBase class LocalBaseClass: pass @PluginBase.register class RegisteredImplementation(LocalBaseClass): def load(self, input): return input.read() def save(self, output, data): return output.write(data) if __name__ == &#39;__main__&#39;: print(&#39;Subclass:&#39;, issubclass(RegisteredImplementation, PluginBase)) print(&#39;Instance:&#39;, isinstance(RegisteredImplementation(), PluginBase))  $ python3 abc_register."/>




<meta property="article:published_time" content="2020-01-18 00:00:00 &#43;0000 UTC" />







    </head>

    <body class="dark-theme">
        <div class="container">
            <header class="header">
    <span class="header__inner">
        <a href="/" style="text-decoration: none;">
    <div class="logo">
        
            <span class="logo__mark">></span>
            <span class="logo__text">$ cd /home/</span>
            <span class="logo__cursor"></span>
        
    </div>
</a>


        <span class="header__right">
            
                <nav class="menu">
    <ul class="menu__inner"><li><a href="/about/">About</a></li><li><a href="/blog/">Blog</a></li>
    </ul>
</nav>

                <span class="menu-trigger">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                        <path d="M0 0h24v24H0z" fill="none"/>
                        <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
                    </svg>
                </span>
            

            <span class="theme-toggle"><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
  3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
  13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"/>
</svg>
</span>
        </span>
    </span>
</header>


            <div class="content">
                
    <main class="post">

        <div class="post-info">
            
            </p>
        </div>

        <article>
            <h2 class="post-title"><a href="/blog/abc/">python中的abc module</a></h2>

            

            <div class="post-content">
                

<h1 id="为什么使用abstract-base-classes">为什么使用abstract base classes?</h1>

<p>抽象基类是一种比hasattr()检查特定方法更严格的接口检查形式。通过定义抽象基类，就可以为一组字类建立公共API。</p>

<h1 id="how-abcs-work">How ABCs Work?</h1>

<p>abc将基础类方法标记为抽象，然后将具体类注册为抽象类的实现。</p>

<pre><code class="language-python"># abc_base.py
import abc

class PluginBase(metaclass=abc.ABCMeta):

    @abc.abstractmethod
    def load(self, input):
        &quot;&quot;&quot;Retrieve data from the input source
        and return an object.
        &quot;&quot;&quot;

    @abc.abstractmethod
    def save(self, output, data):
        &quot;&quot;&quot;Save the data object to the output.&quot;&quot;&quot;
</code></pre>

<h1 id="注册一个具体的类">注册一个具体的类</h1>

<pre><code class="language-python"># abc_register.py
import abc
from abc_base import PluginBase


class LocalBaseClass:
    pass


@PluginBase.register
class RegisteredImplementation(LocalBaseClass):

    def load(self, input):
        return input.read()

    def save(self, output, data):
        return output.write(data)


if __name__ == '__main__':
    print('Subclass:', issubclass(RegisteredImplementation,
                                  PluginBase))
    print('Instance:', isinstance(RegisteredImplementation(),
                                  PluginBase))
</code></pre>

<pre><code class="language-shell">$ python3 abc_register.py

Subclass: True
Instance: True
</code></pre>

<p>从这个案例中，我们可以清楚看到RegisteredImplementation 继承自LocalBaseClass.但是issubclass() 与 isinstance()将他们看作继承自PluginBase.</p>

<h1 id="implementation-through-subclassing">Implementation through Subclassing</h1>

<pre><code class="language-python"># abc_subclass.py
import abc
from abc_base import PluginBase


class SubclassImplementation(PluginBase):

    def load(self, input):
        return input.read()

    def save(self, output, data):
        return output.write(data)


if __name__ == '__main__':
    print('Subclass:', issubclass(SubclassImplementation,
                                  PluginBase))
    print('Instance:', isinstance(SubclassImplementation(),
                                  PluginBase))
</code></pre>

<pre><code class="language-shell">$ python3 abc_subclass.py

Subclass: True
Instance: True
</code></pre>

<p>SubClassing有一个副作用，通过向基类询问派生自plug-in的已知类的列表，可以找到plug-in的所有实现.</p>

<pre><code class="language-python"># abc_find_subclasses.py
import abc
from abc_base import PluginBase
import abc_subclass
import abc_register

for sc in PluginBase.__subclasses__():
    print(sc.__name__)
</code></pre>

<p>尽管abc_register()导入了，RegisteredImplementation不在子类列表中，因为它实际上不是从基类派生的。</p>

<h1 id="helper-base-class">Helper Base Class</h1>

<pre><code class="language-python"># abc_abc_base.py
import abc


class PluginBase(abc.ABC):

    @abc.abstractmethod
    def load(self, input):
        &quot;&quot;&quot;Retrieve data from the input source
        and return an object.
        &quot;&quot;&quot;

    @abc.abstractmethod
    def save(self, output, data):
        &quot;&quot;&quot;Save the data object to the output.&quot;&quot;&quot;


class SubclassImplementation(PluginBase):

    def load(self, input):
        return input.read()

    def save(self, output, data):
        return output.write(data)


if __name__ == '__main__':
    print('Subclass:', issubclass(SubclassImplementation,
                                  PluginBase))
    print('Instance:', isinstance(SubclassImplementation(),
                                  PluginBase))
</code></pre>

<pre><code class="language-shell">$ python3 abc_abc_base.py

Subclass: True
Instance: True
</code></pre>

<h1 id="不完整实现">不完整实现</h1>

<p>类似于Go中接口，当一个struct 实现所有的接口方法，才可以实现接口。</p>

<pre><code class="language-python"># abc_incomplete.py
import abc
from abc_base import PluginBase


@PluginBase.register
class IncompleteImplementation(PluginBase):

    def save(self, output, data):
        return output.write(data)


if __name__ == '__main__':
    print('Subclass:', issubclass(IncompleteImplementation,
                                  PluginBase))
    print('Instance:', isinstance(IncompleteImplementation(),
                                  PluginBase))
</code></pre>

<p>不出意外的，运行后出错。</p>

<pre><code class="language-shell">$ python3 abc_incomplete.py

Subclass: True
Traceback (most recent call last):
  File &quot;abc_incomplete.py&quot;, line 24, in &lt;module&gt;
    print('Instance:', isinstance(IncompleteImplementation(),
TypeError: Can't instantiate abstract class
IncompleteImplementation with abstract methods load
</code></pre>

<h1 id="abcs中的具体方法">ABCs中的具体方法</h1>

<pre><code class="language-python"># abc_concrete_method.py
import abc
import io


class ABCWithConcreteImplementation(abc.ABC):

    @abc.abstractmethod
    def retrieve_values(self, input):
        print('base class reading data')
        return input.read()


class ConcreteOverride(ABCWithConcreteImplementation):

    def retrieve_values(self, input):
        base_data = super(ConcreteOverride,
                          self).retrieve_values(input)
        print('subclass sorting data')
        response = sorted(base_data.splitlines())
        return response


input = io.StringIO(&quot;&quot;&quot;line one
line two
line three
&quot;&quot;&quot;)

reader = ConcreteOverride()
print(reader.retrieve_values(input))
print()
</code></pre>

<p>Since ABCWithConcreteImplementation() is an abstract base class, it is not possible to instantiate it to use it directly.
Subclasses must provide an override for retrieve_values(), and in this case the concrete class sorts the data before returning it.</p>

<pre><code class="language-shell">$ python3 abc_concrete_method.py

base class reading data
subclass sorting data
['line one', 'line three', 'line two']
</code></pre>

<h1 id="抽象属性">抽象属性</h1>

<pre><code class="language-python">abc_abstractproperty.py
import abc


class Base(abc.ABC):

    @property
    @abc.abstractmethod
    def value(self):
        return 'Should never reach here'

    @property
    @abc.abstractmethod
    def constant(self):
        return 'Should never reach here'


class Implementation(Base):

    @property
    def value(self):
        return 'concrete property'

    constant = 'set by a class attribute'


try:
    b = Base()
    print('Base.value:', b.value)
except Exception as err:
    print('ERROR:', str(err))

i = Implementation()
print('Implementation.value   :', i.value)
print('Implementation.constant:', i.constant)
</code></pre>

<pre><code class="language-shell">$ python3 abc_abstractproperty.py

ERROR: Can't instantiate abstract class Base with abstract
methods constant, value
Implementation.value   : concrete property
Implementation.constant: set by a class attribute
</code></pre>

<p>The Base class in the example cannot be instantiated because it has only an abstract version of the property getter methods for value and constant. The value property is given a concrete getter in Implementation and constant is defined using a class attribute.</p>

<p>抽象的读写属性</p>

<pre><code class="language-python"># abc_abstractproperty_rw.py
import abc


class Base(abc.ABC):

    @property
    @abc.abstractmethod
    def value(self):
        return 'Should never reach here'

    @value.setter
    @abc.abstractmethod
    def value(self, new_value):
        return


class PartialImplementation(Base):

    @property
    def value(self):
        return 'Read-only'


class Implementation(Base):

    _value = 'Default value'

    @property
    def value(self):
        return self._value

    @value.setter
    def value(self, new_value):
        self._value = new_value


try:
    b = Base()
    print('Base.value:', b.value)
except Exception as err:
    print('ERROR:', str(err))

p = PartialImplementation()
print('PartialImplementation.value:', p.value)

try:
    p.value = 'Alteration'
    print('PartialImplementation.value:', p.value)
except Exception as err:
    print('ERROR:', str(err))

i = Implementation()
print('Implementation.value:', i.value)

i.value = 'New value'
print('Changed value:', i.value)
</code></pre>

<p>The concrete property must be defined the same way as the abstract property, as either read-write or read-only. Overriding a read-write property in PartialImplementation with one that is read-only leaves the property read-only – the property’s setter method from the base class is not reused.</p>

<pre><code class="language-shell">$ python3 abc_abstractproperty_rw.py

ERROR: Can't instantiate abstract class Base with abstract
methods value
PartialImplementation.value: Read-only
ERROR: can't set attribute
Implementation.value: Default value
Changed value: New value
</code></pre>

<h1 id="抽象类与静态方法">抽象类与静态方法</h1>

<pre><code class="language-python">abc_class_static.py
import abc


class Base(abc.ABC):

    @classmethod
    @abc.abstractmethod
    def factory(cls, *args):
        return cls()

    @staticmethod
    @abc.abstractmethod
    def const_behavior():
        return 'Should never reach here'


class Implementation(Base):

    def do_something(self):
        pass

    @classmethod
    def factory(cls, *args):
        obj = cls(*args)
        obj.do_something()
        return obj

    @staticmethod
    def const_behavior():
        return 'Static behavior differs'


try:
    o = Base.factory()
    print('Base.value:', o.const_behavior())
except Exception as err:
    print('ERROR:', str(err))

i = Implementation.factory()
print('Implementation.const_behavior :', i.const_behavior())
</code></pre>

<p>虽然类方法是在类而不是实例上调用的，但是如果没有定义类，它仍然会阻止类被实例化。</p>

<pre><code class="language-shell">$ python3 abc_class_static.py

ERROR: Can't instantiate abstract class Base with abstract
methods const_behavior, factory
Implementation.const_behavior : Static behavior differs
</code></pre>

            </div>
        </article>

        <hr />

        <div class="post-info">
  			</div>

        
    </main>

            </div>

            
                <footer class="footer">
    <div class="footer__inner">
        
    </div>
    <div class="footer__inner">
        <div class="footer__content">

        </div>
    </div>
    <div class="footer__inner">
        <div class="footer__content">
            <span>Powered by <a href="https://github.com/golang">GOLANG</a></span>
            <span>&copy; 2020</span>
            <span> <a
                href="/posts/index.xml" target="_blank" title="rss"><svg
                    xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 20 20" fill="none"
                    stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
                    class="feather feather-rss">
                    <path d="M4 11a9 9 0 0 1 9 9"></path>
                    <path d="M4 4a16 16 0 0 1 16 16"></path>
                    <circle cx="5" cy="19" r="1"></circle>
                </svg></a></span>
            <span>Made by <a href="https://github.com/tmac33">COSMO</a></span>
        </div>
    </div>
</footer>

            
        </div>

        




<script type="text/javascript" src="/bundle.min.cf7871ed49474a80ed457154d24e61f7881adbe0f9384951a74ac46b688a39a4dbfa68bc6d37baeb058186de354ead3487d4ee7f083ea4cba860c48600b694f3.js" integrity="sha512-z3hx7UlHSoDtRXFU0k5h94ga2&#43;D5OElRp0rEa2iKOaTb&#43;mi8bTe66wWBht41Tq00h9Tufwg&#43;pMuoYMSGALaU8w=="></script>



    </body>
</html>
