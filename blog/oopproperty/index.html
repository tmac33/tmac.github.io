<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="author"
    content="">
<meta name="description"
    content="封装 介绍 封装（encapsulation)就是把抽象出的字段与对字段的操作封装在一起，数据被保护在内部，程序的其他包只有通过被授权的操作（方法），才能对字段进行操作。
举例：对电视机的操作就是典型的封装
理解与优点  隐藏实现的细节 对数据进行验证，保证安全合理  如何体现封装  对结构体中的属性进行封装 通过方法，包，实现封装  封装的实现步骤  将结构体，字段（属性）的首字母小写（不能导出了，其他包不能使用，类似private） 给结构体所在的包提供一个工厂模式的函数，首字母大写。类似一个构造函数 提供一个首字母大写的Set方法（类似与其它语言的public），用于对属性判断并赋值  func(var 结构体类型名) SetXxx(参数列表) (返回值列表){ //加入数据验证的业务逻辑 var.字段=参数 }
 提供一个首字母大写的get方法（类似于其他语言的public），用于获取属性的值  func (var 结构体类型名) GetXxx() { return var.age; }
快速入门 案例：请大家看一个程序(person.go)，不能随便查看人的年龄，工资等隐私，并对输入的年龄进行合理验证。设计model包(person.go)main包(main.go 调用person结构体)
代码实现：
model/person.go
package model import &amp;quot;fmt&amp;quot; type person struct{ Name string age int //其他包不可以访问 sal float64 } //写一个工厂模式的函数，相当于构造函数 func NewPerson(name string) *person{ return &amp;amp;person{ Name:name, } } //为了访问age和sal我们编写一对SetXxx的方法和GetXxx的方法 func (p *person) SetAge(age int) { if age&amp;gt;0&amp;amp;&amp;amp;age&amp;lt;150{ p." />
<meta name="keywords" content="Golang&amp;.Net Core" />
<meta name="robots" content="noodp" />
<link rel="canonical" href="/blog/oopproperty/" />


<title>
    
    面向对象的三大特性 :: Code and Things  — Cosmo Wu
    
</title>



<link href="https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.2.1/css/flag-icon.min.css" rel="stylesheet"
    type="text/css">



<link rel="stylesheet" href="/main.min.91687bbfc139d7ff1a244bb6d7324425f9c4f424eaaad242b478e3b3cf56396a.css">



<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#252627">
<link rel="shortcut icon" href="/favicon.ico">
<meta name="theme-color" content="#252627">
<meta itemprop="name" content="面向对象的三大特性">
<meta itemprop="description" content="封装 介绍 封装（encapsulation)就是把抽象出的字段与对字段的操作封装在一起，数据被保护在内部，程序的其他包只有通过被授权的操作（方法），才能对字段进行操作。
举例：对电视机的操作就是典型的封装
理解与优点  隐藏实现的细节 对数据进行验证，保证安全合理  如何体现封装  对结构体中的属性进行封装 通过方法，包，实现封装  封装的实现步骤  将结构体，字段（属性）的首字母小写（不能导出了，其他包不能使用，类似private） 给结构体所在的包提供一个工厂模式的函数，首字母大写。类似一个构造函数 提供一个首字母大写的Set方法（类似与其它语言的public），用于对属性判断并赋值  func(var 结构体类型名) SetXxx(参数列表) (返回值列表){ //加入数据验证的业务逻辑 var.字段=参数 }
 提供一个首字母大写的get方法（类似于其他语言的public），用于获取属性的值  func (var 结构体类型名) GetXxx() { return var.age; }
快速入门 案例：请大家看一个程序(person.go)，不能随便查看人的年龄，工资等隐私，并对输入的年龄进行合理验证。设计model包(person.go)main包(main.go 调用person结构体)
代码实现：
model/person.go
package model import &quot;fmt&quot; type person struct{ Name string age int //其他包不可以访问 sal float64 } //写一个工厂模式的函数，相当于构造函数 func NewPerson(name string) *person{ return &amp;person{ Name:name, } } //为了访问age和sal我们编写一对SetXxx的方法和GetXxx的方法 func (p *person) SetAge(age int) { if age&gt;0&amp;&amp;age&lt;150{ p.">


<meta itemprop="datePublished" content="2016-12-29T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2016-12-29T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="789">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="/"/>

<meta name="twitter:title" content="面向对象的三大特性"/>
<meta name="twitter:description" content="封装 介绍 封装（encapsulation)就是把抽象出的字段与对字段的操作封装在一起，数据被保护在内部，程序的其他包只有通过被授权的操作（方法），才能对字段进行操作。
举例：对电视机的操作就是典型的封装
理解与优点  隐藏实现的细节 对数据进行验证，保证安全合理  如何体现封装  对结构体中的属性进行封装 通过方法，包，实现封装  封装的实现步骤  将结构体，字段（属性）的首字母小写（不能导出了，其他包不能使用，类似private） 给结构体所在的包提供一个工厂模式的函数，首字母大写。类似一个构造函数 提供一个首字母大写的Set方法（类似与其它语言的public），用于对属性判断并赋值  func(var 结构体类型名) SetXxx(参数列表) (返回值列表){ //加入数据验证的业务逻辑 var.字段=参数 }
 提供一个首字母大写的get方法（类似于其他语言的public），用于获取属性的值  func (var 结构体类型名) GetXxx() { return var.age; }
快速入门 案例：请大家看一个程序(person.go)，不能随便查看人的年龄，工资等隐私，并对输入的年龄进行合理验证。设计model包(person.go)main包(main.go 调用person结构体)
代码实现：
model/person.go
package model import &quot;fmt&quot; type person struct{ Name string age int //其他包不可以访问 sal float64 } //写一个工厂模式的函数，相当于构造函数 func NewPerson(name string) *person{ return &amp;person{ Name:name, } } //为了访问age和sal我们编写一对SetXxx的方法和GetXxx的方法 func (p *person) SetAge(age int) { if age&gt;0&amp;&amp;age&lt;150{ p."/>




<meta property="article:published_time" content="2016-12-29 00:00:00 &#43;0000 UTC" />







    </head>

    <body class="dark-theme">
        <div class="container">
            <header class="header">
    <span class="header__inner">
        <a href="/" style="text-decoration: none;">
    <div class="logo">
        
            <span class="logo__mark">></span>
            <span class="logo__text">$ cd /home/</span>
            <span class="logo__cursor"></span>
        
    </div>
</a>


        <span class="header__right">
            
                <nav class="menu">
    <ul class="menu__inner"><li><a href="/about/">About</a></li><li><a href="/blog/">Blog</a></li>
    </ul>
</nav>

                <span class="menu-trigger">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                        <path d="M0 0h24v24H0z" fill="none"/>
                        <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
                    </svg>
                </span>
            

            <span class="theme-toggle"><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
  3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
  13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"/>
</svg>
</span>
        </span>
    </span>
</header>


            <div class="content">
                
    <main class="post">

        <div class="post-info">
            
            </p>
        </div>

        <article>
            <h2 class="post-title"><a href="/blog/oopproperty/">面向对象的三大特性</a></h2>

            

            <div class="post-content">
                

<h1 id="封装">封装</h1>

<h2 id="介绍">介绍</h2>

<p>封装（encapsulation)就是把抽象出的字段与对字段的操作封装在一起，数据被保护在内部，程序的其他包只有通过被授权的操作（方法），才能对字段进行操作。</p>

<p>举例：对电视机的操作就是典型的封装</p>

<h2 id="理解与优点">理解与优点</h2>

<ul>
<li>隐藏实现的细节</li>
<li>对数据进行验证，保证安全合理</li>
</ul>

<h2 id="如何体现封装">如何体现封装</h2>

<ul>
<li>对结构体中的属性进行封装</li>
<li>通过方法，包，实现封装</li>
</ul>

<h2 id="封装的实现步骤">封装的实现步骤</h2>

<ol>
<li>将结构体，字段（属性）的首字母小写（不能导出了，其他包不能使用，类似private）</li>
<li>给结构体所在的包提供一个工厂模式的函数，首字母大写。类似一个构造函数</li>
<li>提供一个首字母大写的Set方法（类似与其它语言的public），用于对属性判断并赋值</li>
</ol>

<p>func(var 结构体类型名) SetXxx(参数列表) (返回值列表){
    //加入数据验证的业务逻辑
    var.字段=参数
}</p>

<ol>
<li>提供一个首字母大写的get方法（类似于其他语言的public），用于获取属性的值</li>
</ol>

<p>func (var 结构体类型名) GetXxx() {
    return var.age;
}</p>

<h2 id="快速入门">快速入门</h2>

<p>案例：请大家看一个程序(person.go)，不能随便查看人的年龄，工资等隐私，并对输入的年龄进行合理验证。设计model包(person.go)main包(main.go 调用person结构体)</p>

<p>代码实现：</p>

<p>model/person.go</p>

<pre><code class="language-go">package model
import &quot;fmt&quot;

type person struct{
    Name string
    age int  //其他包不可以访问
    sal float64
}

//写一个工厂模式的函数，相当于构造函数
func NewPerson(name string) *person{
    return &amp;person{
        Name:name,
    }
}

//为了访问age和sal我们编写一对SetXxx的方法和GetXxx的方法
func (p *person) SetAge(age int) {
    if age&gt;0&amp;&amp;age&lt;150{
        p.age=age
    } else {
        fmt.Println(&quot;年龄范围不正确。。&quot;)
        //给一个默认值
    }
}

func (p *person) GetAge() int{
    return p.age
}

func (p *person) SetSal(sal float64) {
    if sal&gt;=3000&amp;&amp;sal&lt;=30000{
        p.sal=sal
    } else {
        fmt.Println(&quot;x薪水范围不正确。。&quot;)
    }
}

func (p *person) GetSal() float64{
    return p.sal
}

</code></pre>

<p>main/main.go</p>

<pre><code class="language-go">package main

import (
    &quot;fmt&quot;
    &quot;model&quot;
)

func main() {
    p:=model.NewPerson(&quot;smith&quot;)
    p.SetAge(18)
    p.SetAl(5000)
    fmt.Println(p)
    fmt.Println(p.Name,&quot;age=&quot;,p.GetAge(),&quot;sal=&quot;,p.GetSal())
}

</code></pre>

<h1 id="继承">继承</h1>

<p>继承可以解决代码复用，让我们的编程更加靠近人类思维。</p>

<p>当多个结构体存在相同的属性（字段）和方法时，可以从这些结构体中抽象出结构体（比如大学生，小学生，中学生），在结构体中定义这些相同的属性和方法。</p>

<p>其他的结构体不需要重新定义这些属性（字段）和方法，只需要嵌套一个student匿名结构体即可。</p>

<p><img src="https://i.loli.net/2019/06/01/5cf1ebb2df0e966753.png" alt="继承" /></p>

<p>也就是说：在golang中，如果一个struct嵌套了另一个匿名结构体，那么这个结构体可以直接访问匿名结构体的字段和方法，从而实现了继承特性。</p>

<h2 id="基本语法">基本语法</h2>

<pre><code class="language-go">type Goods struct{
    Name string
    Price int
}

type Book struct{
    Goods //这里就嵌套匿名结构体Goods
    Writer string
}

</code></pre>

<h2 id="快速入门案例">快速入门案例</h2>

<p>还是以大学生，小学生，中学生为例</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

//编写一个学生考试系统
type Student struct{
    Name string
    Age int
    Score int
}

//将Pupil和Graduate共有的方法也绑定到* Student
func (stu *Student) ShowInfo() {
    fmt.Printf(&quot;学生名=%v 年龄=%v 成绩=%v\n&quot;,stu.Name,stu.Age,stu.Score)
}

func (stu *Student) SetScore(score int){
    stu.Score=score
}

//小学生

type Pupil struct{
    Student //嵌入Student匿名结构体
}

//显示他的成绩

//这时Pupil结构体特有的方法保留
func (p *Pupil) testing() {
    fmt.Println(&quot;小学生正在考试。。。&quot;)
}

//大学生，研究生

//大学生
type Graduate struct{
    Student //嵌入了student匿名结构体
}

//显示他的成绩
//这时Graduate结构体特有的方法，保留
func (p *Graduate) testing() {
    fmt.Println(&quot;大学生正在考试中&quot;)
}

//代码冗余，高中生

func main() {
    //当我们对结构体嵌入了匿名结构体使用方法会有变化
    pupil:=&amp;Pupil{}
    pupil.Student.Name=&quot;tom&quot;
    pupil.Student.Age=8
    pupil.teating()
    pupil.Student.SetScore(70)
    pupil.Student.ShowInfo()
}

</code></pre>

<h2 id="继承带来的便利性">继承带来的便利性</h2>

<ul>
<li>代码的复用性提高了</li>
<li>代码的扩张性与维护性提高了</li>
</ul>

<h2 id="深入理解继承">深入理解继承</h2>

<ol>
<li><p>结构体可以使用嵌套匿名结构体所有的字段与方法，即：首字母大写或者小写的字段，方法，都可以使用。</p></li>

<li><p>匿名结构体字段访问可以简化。</p></li>
</ol>

<pre><code class="language-go">type A struct{
    Name string
    age int
}

type B struct{
    A
}

var b B

b.A.Name=&quot;tom&quot;

//可以简化为
b.Name=&quot;smith&quot;

</code></pre>

<p>对上面代码的小结&mdash;-洋葱理论</p>

<p>1). 当我们直接通过b访问字段或者方法时，其执行流程如下比如b.Name
  2). 编译器会首先看b对应的类型有没有Name，如果有，则直接调用B类型的Name字段
  3). 如果B没有，才会去寻找A，如果在A中也没有找到则会继续查找，直到未找到，报错。</p>

<ol>
<li><p>当结构体和匿名结构体有相同方法或者字段时，编译器采用就近原则。</p></li>

<li><p>结构体嵌入两个或多个匿名结构体，如两个匿名结构体有相同的字段和方法（同时结构体本身没有同名的字段与方法）在访问时，就必须指定匿名结构体的名字，否则会编译报错。</p></li>

<li><p>如果一个struct嵌套了一个有名结构体，这种模式就是组合，如果是组合关系，那么在访问组合的结构体字段或者方法时，必须带上结构体的名字</p></li>
</ol>

<pre><code class="language-go">type D struct{
    a A //有名结构体
}

//如果D中有一个有名的结构体，则访问有名结构体的字段时候，必须带上有名结构体的名字

var d D
d.a.Name=&quot;jack&quot;

</code></pre>

<ol>
<li>嵌套匿名结构体后，也可以在创建结构体变量时，直接指定匿名结构体字段的值。</li>
</ol>

<h2 id="多重继承">多重继承</h2>

<p>如果一个struct嵌套了多个匿名结构体，那么该结构体可以直接访问嵌套的匿名结构体的字段和方法，从而实现了多重继承。</p>

<h1 id="接口">接口</h1>

<pre><code class="language-go">package main

import &quot;fmt&quot;

//声明/定义一个接口
type Usb interface{
    // 声明两个没有实现的方法
    Start()
    Stop()
}

typr Phone struct{

}

//让iphone实现Usb接口的方法
func (p Phone) Start() {
    fmt.Println(&quot;手机开始工作&quot;)
}

func (p Phone) Stop() {
    fmt.Println(&quot;手机停止工作&quot;)
}

type Camera struct{

}

//让相机实现USB方法
func (c Camera) Start() {
    fmt.Println(&quot;相机开始工作&quot;)
}

func (c Camera) Stop() {
    fmt.Println(&quot;相机停止工作&quot;)
}

//计算机
type Computer struct{

}

//编写一个working方法，接收一个USB接口类型变量
//只要是实现了USB接口（所谓的实现usb接口，就是指实现了usb接口声明的所有方法）
func (c Computer) Working(usb Usb){
    //usb变量会根据传入的实参，来判断到底是phone，还是camera
    //通过usb接口来调用start和stop方法

    usb.Start()
    usb.Stop()
}

func main() {
    //先创建结构体变量
    computer:=Computer{}
    phone:=Phone{}
    camera:=Camera{}

    //关键点
    computer.Working(phone)
    computer.Working(camera)
}

</code></pre>

<h2 id="接口概念">接口概念</h2>

<p>interface类型可以定义一组方法，但是这些不需要实现。并且interface不包含任何变量。到某个自定义类型要使用的时候，再根据具体的情况把这些方法写出来（实现）。</p>

<p>说明：</p>

<ol>
<li>接口里的所有方法都没有方法体，即接口的方法都是没有实现的方法。接口体现了程序设计的 ==多态和高内聚低耦合== 的思想。</li>
<li>golang的接口，==不需要显示的实现==。只要一个变量，含有接口类型的所有方法，那么这个变量就实现了这个接口。</li>
</ol>

<h2 id="使用场景">使用场景</h2>

<p>对于初学者来说，理解接口的概念不算太难，难的是不知道如何使用接口。下面我例举几个应用场景：</p>

<ol>
<li><p>中国要制造轰炸机，武装直升机，专家只需要把飞机所需要的功能与规格定下来，然后让别人具体实现就行。</p></li>

<li><p>一个项目经理，管理三个程序员，开发一个软件，为了控制与管理软件，项目经理可以定义一些接口，然后让程序员具体实现就可以。</p></li>
</ol>

<h2 id="注意事项">注意事项</h2>

<ol>
<li>接口本身不能创建实例，但是可以指向一个实现了该接口的自定义类型的变量</li>
</ol>

<pre><code class="language-go">package main

import &quot;fmt&quot;

type AInterface interface{
    Say()
}

type Stu struct{
    Name string
}

func (stu Stu) Say(){
    fmt.Println(&quot;stu Say()&quot;)
}

func main() {
    var stu Stu  
    var a AInterface =stu
    a.Say()
}

</code></pre>

<ol>
<li><p>接口中所有的方法都没有方法体，即都是没有实现的方法</p></li>

<li><p>在golang中，一个自定义类型需要实现接口的所有方法，我们才可以说这个自定义类型实现了该接口。</p></li>

<li><p>一个自定义类型只有实现了某个接口，才能将自定义类型的实例赋给接口类型</p></li>

<li><p>只要是自定义数据类型，就可以实现接口，不仅仅是结构体类型</p></li>
</ol>

<pre><code class="language-go">type integer int

func (i integer) Say(){
    fmt.Println(&quot;integer say i =&quot;, i)
}

var i integer =10
var b AInterface=i
b.Say()

</code></pre>

<ol>
<li><p>一个自定义类型可以实现多个接口</p></li>

<li><p>golang接口中不可以有任何变量</p></li>
</ol>

<pre><code class="language-go">type AInterface interface{
    Name string
    Test01()
    Test02()
}
</code></pre>

<ol>
<li>一个接口（比如A接口）可以继承多个别的接口（比如B,C接口），这时候如果要实现A接口，也必须将B,C接口的方法全部实现。</li>
</ol>

<pre><code class="language-go">package main

import &quot;fmt&quot;

type BInterface interface{
    test01()
}

type CInterface interface {
    test02()
}

type AInterface interface{
    BInterface
    CInterface
    test03()
}

type Stu struct{

}

func (stu Stu) test01{

}

func (stu Stu) test02{

}

func (stu Stu) test03{

}

func main (){
    var stu Stu
    var a AInterface=stu
    a.teat01()
}


</code></pre>

<ol>
<li><p>interface类型默认是一个指针（引用类型），如果没有interface初始化就使用，那么会输出nil</p></li>

<li><p>空接口interface{} 没有任何方法，所以所有类型都实现了空接口，即我们可以把任何一个变量赋值给空接口。</p></li>
</ol>

<h2 id="接口与继承的对比">接口与继承的对比</h2>

<pre><code class="language-go">package main

import &quot;fmt&quot;

type Monkey struct{
    Name string
}

type BirdAble interface{
    Flying()
}

type FishAble interface{
    Swimming()
}

func (this *Monkey) climbing(){
    fmt.Println(this.Name, &quot;生来会爬树&quot;)
}

type LittleMonkey struct{
    Monkey  //继承
}

//让小猴子报一点兴趣班

func (this *LittleMonkey) Flying(){
    fmt.Println(this.Name,&quot;通过学习会飞&quot;)
}

func (this *LittleMonkey) Swimming(){
    fmt.Println(this.Name,&quot;通过学习会游泳&quot;)
}

func main () {
    monkey:=LittleMonkey{
        Monkey{
            Name:&quot;悟空&quot;,
        },
    }

    monkey.climbing()
    monkey.Flying()
    monkey.Swimming()
}

</code></pre>

<p>代码总结：</p>

<p>1). 当A结构体继承B结构体，那么A自然就继承了B的字段与方法，并且可以直接使用
2). 当A需要扩张功能，同时不许王破坏继承关系，则可以去实现某个接口即可。因此我们认为 ==实现接口是对继承机制的补充==</p>

<p>接口与继承解决的问题不同</p>

<p>继承的价值在于：解决代码复用性与可维护性
接口的价值在于：设计，设计各种好的规范与方法，让其他自定义类型去实现这些方法。</p>

<p>接口一定程度上实现了代码的解耦</p>

<h1 id="多态">多态</h1>

<p>变量具有多种形态。面向对象的第三大特征，就go语言，多态特征是通过接口实现的。可以按照统一的接口来调用不同的实现，这时接口变量就呈现不同的形态</p>

<p>在前面接口章节，usb接口案例，usb既可以接收手机变量，又可以接收相机变量，就体现usb接口的多态特征。</p>

<h2 id="接口体现多态的两种形式">接口体现多态的两种形式</h2>

<ol>
<li><p>多态参数</p></li>

<li><p>多态数组</p></li>
</ol>

<h1 id="类型断言">类型断言</h1>

<p>先看一段代码：</p>

<pre><code class="language-go">type Point struct{
    x,y int
}

func main() {
    var a interface{}
    var point Point=Point{1,2}
    //point赋值给接口a是可以的
    a=point
    //如何将a付给一个point变量？
    var b Point
    b=a  // 可以吗？ =》error
}

</code></pre>

<p>需求：如何将一个接口变量，赋给自定义类型的变量？</p>

<p>因此引申出》》》》类型断言</p>

<p>关于上面代码的解决办法为：</p>

<pre><code class="language-go">func main() {
    var a interface{}
    var point Point=Point{1,2}
    a=point
    var b point
    b=a.(Point)  //类型断言
    fmt.Println(b)
}
</code></pre>

<p>b=a.(Point)就是类型断言，表示判断a是否指向Point类型的变量，如果是就转成Point类型并付给b变量，否则报错</p>

<h2 id="基本介绍">基本介绍</h2>

<p>类型断言，由于接口是一般类型，不知道具体类型，如果要转成具体类型，就需要使用类型断言，具体如下：</p>

<pre><code class="language-go">var x interface{}
var b2 float32=1.1
x=b2 //空接口可以接收任意类型
//使用类型断言
y:=x.(float32)
fmt.Printf(&quot;y的类型是%T 值是%v&quot;, y,y)
</code></pre>

<p>在进行类型断言时，如果类型不匹配，就会报panic，因此进行类型断言时，要确保原来的空接口指向的就是断言的类型</p>

<p>断言的检测机制：</p>

<pre><code class="language-go">var x interface{}

var b2 float32=2.1
x=b2  //空接口，可以接收任意类型

//类型断言（检测）
if y,ok:=x.(float32);ok{
    //成功
} else{
    //失败
}
fmt.Println(&quot;继续执行&quot;)
</code></pre>

<h2 id="实践">实践</h2>

<pre><code class="language-go">package main

import (
    &quot;fmt&quot;
)

type Usb interface{
    Start()
    Stop()
}

type Phone struct{
    name string
}

func (p Phone) Start() {
    fmt.Println(&quot;手机开始工作。。。&quot;)
}

func (p Phone) Stop() {
    fmt.Println(&quot;手机停止工作。。。&quot;)
}

func (p Phone) Call() {
    fmt.Println(&quot;手机在打电话。。。&quot;)
}

type Camera struct{
    name string
}

func (c Camera) Start() {
    fmt.Println(&quot;相机开始工作。。。&quot;)
}

func (c Camera) Stop() {
    fmt.Println(&quot;相机停止工作。。。&quot;)
}

type Computer struct{}

func (computer Computer) Working(usb Usb) {
    usb.Start()

    //如果usb是指向phone结构体变量，则还需要调用Call方法
    if phone,ok:=usb.(Phone);ok{
        phone.Call()
    }

    usb.Stop()
}

func main(){
    //定义一个Usb接口数组，可以存放Phone和Camera的结构体变量
    //这里就体现出多态数组

    var usbArr [3]Usb

    usbArr[0]=Phone{&quot;vivo&quot;}
    usbArr[1]=Phone{&quot;小米&quot;}
    usbArr[2]=Phone{&quot;尼康&quot;}

    //遍历usbArr
    //phone还有一个特有的方法call()，请遍历usb数组，如果是phone变量
    //除了调用usb接口声明的方法外，还需要调用phone特有方法call
    var computer Computer
    for _,v:=range usbArr{
        computer.Working(v)
    }
}

</code></pre>

<p>实践2：写一个函数，循环判断传入的参数类型：</p>

<pre><code class="language-go">package main

import (
    &quot;fmt&quot;
)

func TypeJudge(items... interface{}) {
    for index,x:=range items{
        switch x.(type) {
        case bool:
            fmt.Println()
        case float32:
            fmt.Println()
        case int,int32,int64:
            fmt.Println()
        default:
            fmt.Println()
        }
    }
}

func main() {
    TypeJudge(...)
}


</code></pre>

            </div>
        </article>

        <hr />

        <div class="post-info">
  			</div>

        
    </main>

            </div>

            
                <footer class="footer">
    <div class="footer__inner">
        
    </div>
    <div class="footer__inner">
        <div class="footer__content">

        </div>
    </div>
    <div class="footer__inner">
        <div class="footer__content">
            <span>Powered by <a href="https://github.com/golang">GOLANG</a></span>
            <span>&copy; 2019</span>
            <span> <a
                href="/posts/index.xml" target="_blank" title="rss"><svg
                    xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 20 20" fill="none"
                    stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
                    class="feather feather-rss">
                    <path d="M4 11a9 9 0 0 1 9 9"></path>
                    <path d="M4 4a16 16 0 0 1 16 16"></path>
                    <circle cx="5" cy="19" r="1"></circle>
                </svg></a></span>
            <span>Made by <a href="https://github.com/tmac33">COSMO</a></span>
        </div>
    </div>
</footer>

            
        </div>

        




<script type="text/javascript" src="/bundle.min.cf7871ed49474a80ed457154d24e61f7881adbe0f9384951a74ac46b688a39a4dbfa68bc6d37baeb058186de354ead3487d4ee7f083ea4cba860c48600b694f3.js" integrity="sha512-z3hx7UlHSoDtRXFU0k5h94ga2&#43;D5OElRp0rEa2iKOaTb&#43;mi8bTe66wWBht41Tq00h9Tufwg&#43;pMuoYMSGALaU8w=="></script>



    </body>
</html>
