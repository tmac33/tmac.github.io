<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Code and Things</title>
    <link>/</link>
    <description>Recent content on Code and Things</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 18 Jan 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>python中的abc module</title>
      <link>/blog/abc/</link>
      <pubDate>Sat, 18 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>/blog/abc/</guid>
      <description>为什么使用abstract base classes? 抽象基类是一种比hasattr()检查特定方法更严格的接口检查形式。通过定义抽象基类，就可以为一组字类建立公共API。
How ABCs Work? abc将基础类方法标记为抽象，然后将具体类注册为抽象类的实现。
# abc_base.py import abc class PluginBase(metaclass=abc.ABCMeta): @abc.abstractmethod def load(self, input): &amp;quot;&amp;quot;&amp;quot;Retrieve data from the input source and return an object. &amp;quot;&amp;quot;&amp;quot; @abc.abstractmethod def save(self, output, data): &amp;quot;&amp;quot;&amp;quot;Save the data object to the output.&amp;quot;&amp;quot;&amp;quot;  注册一个具体的类 # abc_register.py import abc from abc_base import PluginBase class LocalBaseClass: pass @PluginBase.register class RegisteredImplementation(LocalBaseClass): def load(self, input): return input.read() def save(self, output, data): return output.write(data) if __name__ == &#39;__main__&#39;: print(&#39;Subclass:&#39;, issubclass(RegisteredImplementation, PluginBase)) print(&#39;Instance:&#39;, isinstance(RegisteredImplementation(), PluginBase))  $ python3 abc_register.</description>
    </item>
    
    <item>
      <title>原本的新起点</title>
      <link>/blog/newdispointing/</link>
      <pubDate>Mon, 23 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>/blog/newdispointing/</guid>
      <description>初识Oracle 我已经快2年没有工作过了，一直花的都是积蓄，过得都是困苦。本来就已经很自卑了，但自己不知为何总是不愿意去做一些几乎所有的留学生都会干的端盘子洗碗的工作，毕竟这一般才是一个正儿八经的留学生，生活的常态。但我耳边，总有人一句话在回荡，
 &amp;ldquo;晓阳，出国了不要去做一些端盘子洗碗的工作，那样没意义”
 这句话来自一个在洛杉矶跟大阪呆了几年的前辈。我也认同，毕竟这已经不是，80年代的中外环境了，没必要委屈求全，而且我一再认为，职业是成就人生的不二法宝，你在国内有人前显贵的职业生涯，就真没必要，跑到外国，人前卑微的争着，挥霍自己职业生涯的那一点生活保障。虽然王小波刚开始在西雅图的那几年也干过这事，但他确实也没干几天。如果你观察，你就会发现，新西兰的很多年轻中国留学生，为了一个PR大都毁了自己，在坚持干着一些，国内同龄青年完全看不起的一些职业。着实惋惜。
话说回来，我这呢，也已经被这没有工作的两年磨得眼睛失去了光，嘴上没有了倔。但别人不能提。提了的话我的玻璃心就会碎一地。
大概一个月前的周六中午，我接女友下班，（我依旧愿意将领了结婚证的媳妇，称为女友的原因是，我不想在落魄的时候，多一个老婆。）她微信告诉我，同事们说，
 “你应该叫你老公也上班，你一个人挣的钱，够你俩花吗”？
 有意思的是，说这话同事，此刻还坐在我的车上，我顺路捎她回家。
此刻呢，我就像一个，笨手笨脚的梁上君子，被人抓住后，撕掉了面具一般害怕且愤怒。
回到家后，我想起来，朋友圈内的朋友好像发过，有个招聘的消息，那是我们家楼上另一个租客的朋友圈，我就借机在见面的时候，假装提起，她真是一个好心人，她发给了我信息，还主动帮我联系了人，打开信息一看，居然是Oracle，顿时欣喜又惶恐。
Oracle的面试官 还没完，待续。。。。</description>
    </item>
    
    <item>
      <title>深度优先与广度优先</title>
      <link>/blog/dfsbfs/</link>
      <pubDate>Sat, 13 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/blog/dfsbfs/</guid>
      <description>什么是 深度/广度 优先遍历？ 深度优先遍历简称DFS（Depth First Search），广度优先遍历简称BFS（Breadth First Search），它们是遍历图当中所有顶点的两种方式。 这两种遍历方式有什么不同呢？我们来举个栗子： 我们来到一个游乐场，游乐场里有11个景点。我们从景点0开始，要玩遍游乐场的所有景点，可以有什么样的游玩次序呢？
第一种是一头扎到底的玩法。我们选择一条支路，尽可能不断地深入，如果遇到死路就往回退，回退过程中如果遇到没探索过的支路，就进入该支路继续深入。 在图中，我们首先选择景点1的这条路，继续深入到景点7、景点8，终于发现走不动了（景点旁边的数字代表探索次序）：
于是，我们退回到景点7，然后探索景点10，又走到了死胡同。于是，退回到景点1，探索景点9：
按照这个思路，我们再退回到景点0，后续依次探索景点2、3、5、4、6，终于玩遍了整个游乐场：
像这样先深入探索，走到头再回退寻找其他出路的遍历方式，就叫做深度优先遍历（DFS）。
除了像深度优先遍历这样一头扎到底的玩法以外，我们还有另一种玩法：首先把起点相邻的几个景点玩遍，然后去玩距离起点稍远一些（隔一层）的景点，然后再去玩距离起点更远一些（隔两层）的景点&amp;hellip;&amp;hellip; 在图中，我们首先探索景点0的相邻景点1、2、3、4：
接着，我们探索与景点0相隔一层的景点7、9、5、6：
最后，我们探索与景点0相隔两层的景点8、10：
像这样一层一层由内而外的遍历方式，就叫做广度优先遍历（BFS）。
深度/广度优先遍历 的实现 深度优先遍历 首先说说深度优先遍历的实现过程。这里所说的回溯是什么意思呢？回溯顾名思义，就是自后向前，追溯曾经走过的路径。
我们把刚才游乐场的例子抽象成数据结构的图，假如我们依次访问了顶点0、1、7、8，发现无路可走了，这时候我们要从顶点8退回到顶点7。
而后我们探索了顶点10，又无路可走了，这时候我们要从顶点10退回到顶点7，再退回到顶点1。
像这样的自后向前追溯曾经访问过的路径，就叫做回溯。 要想实现回溯，可以利用栈的先入后出特性，也可以采用递归的方式（因为递归本身就是基于方法调用栈来实现）。
下面我们来演示一下具体实现过程。
首先访问顶点0、1、7、8，这四个顶点依次入栈，此时顶点8是栈顶：
从顶点8退回到顶点7，顶点8出栈：
接下来访问顶点10，顶点10入栈：
从顶点10退到顶点7，从顶点7退到顶点1，顶点10和顶点7出栈：
探索顶点9，顶点9入栈：
以此类推，利用这样一个临时栈来实现回溯，最终遍历完所有顶点。
广度优先遍历 接下来该说说广度优先遍历的实现过程了。刚才所说的重放是什么意思呢？似乎听起来和回溯差不多？其实，回溯与重放是完全相反的过程。
仍然以刚才的图为例，按照广度优先遍历的思想，我们首先遍历顶点0，然后遍历了邻近顶点1、2、3、4：
接下来我们要遍历更外围的顶点，可是如何找到这些更外围的顶点呢？我们需要把刚才遍历过的顶点1、2、3、4按顺序重新回顾一遍，从顶点1发现邻近的顶点7、9；从顶点3发现邻近的顶点5、6。
像这样把遍历过的顶点按照之前的遍历顺序重新回顾，就叫做重放。同样的，要实现重放也需要额外的存储空间，可以利用队列的先入先出特性来实现。
下面我们来演示一下具体实现过程。
首先遍历起点顶点0，顶点0入队：
接下来顶点0出队，遍历顶点0的邻近顶点1、2、3、4，并且把它们入队：
然后顶点1出队，遍历顶点1的邻近顶点7、9，并且把它们入队：
然后顶点2出队，没有新的顶点可入队：
以此类推，利用这样一个队列来实现重放，最终遍历完所有顶点。
代码实现Golang 树的定义 package tree type Node struct { Val int Left *Node Right *Node }  深度优先遍历 深度优先遍历需要优先使用栈
栈的定义 type Stack struct { list *list.</description>
    </item>
    
    <item>
      <title>区分new与make</title>
      <link>/blog/newmake/</link>
      <pubDate>Wed, 10 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/blog/newmake/</guid>
      <description>转载自飞雪无情
 Go语言中new和make是内建的两个函数，主要用来创建分配类型内存。在我们定义生成变量的时候，可能会觉得有点迷惑，其实他们的规则很简单，下面我们就通过一些示例说明他们的区别和使用。
变量的声明 var i int var s string  变量的声明我们可以通过var关键字，然后就可以在程序中使用。当我们不指定变量的默认值时，这些变量的默认值是他们的零值，比如int类型的零值是0,string类型的零值是&amp;rdquo;&amp;ldquo;，引用类型的零值是nil。
对于例子中的两种类型的声明，我们可以直接使用，对其进行赋值输出。但是如果我们换成引用类型呢？
package main import ( &amp;quot;fmt&amp;quot; ) func main() { var i *int *i=10 fmt.Println(*i) }  这个例子会打印出什么？0还是10?。以上全错，运行的时候会painc，如下：
 panic: runtime error: invalid memory address or nil pointer dereference
 从这个提示中可以看出，对于引用类型的变量，我们不光要声明它，还要为它分配内容空间，否则我们的值放在哪里去呢？这就是上面错误提示的原因。
对于值类型的声明不需要，是因为已经默认帮我们分配好了。
要分配内存，就引出来今天的new和make。
new 对于上面的问题我们如何解决呢？既然我们知道了没有为其分配内存，那么我们使用new分配一个吧。
func main() { var i *int i=new(int) *i=10 fmt.Println(*i) }  现在再运行程序，完美PASS，打印10。现在让我们看下new这个内置的函数。
// The new built-in function allocates memory. The first argument is a type, // not a value, and the value returned is a pointer to a newly // allocated zero value of that type.</description>
    </item>
    
    <item>
      <title>深入理解defer</title>
      <link>/blog/defer/</link>
      <pubDate>Sun, 07 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/blog/defer/</guid>
      <description>defer语句是一个非常有用的特性，可以将一个方法延迟到包裹该方法的方法返回时执行，在实际应用中，defer语句可以充当其他语言中try&amp;hellip;catch的角色，也可以用来处理关闭文件句柄等收尾操作。
defer触发的时机  A &amp;ldquo;defer&amp;rdquo; statement invokes a function whose execution is deferred to the moment the surrounding function returns,either because the surrounding function executed a return statement, reached the end of its function body,or because the corresponding goroutine is panicking.
 GO官方文档中对defer的执行时机做了阐述，分别是：
 包裹defer的函数返回时 包裹defer的函数执行到末尾时 所在的goroutine发生panic时  defer的执行顺序 当一个方法有多个defer时，defer会将延迟执行的方法“压栈”，当defer被触发时，将所有的“压栈”的方法“出栈”并执行。所以defer的执行顺序是LIFO的。
所以下面这段代码的输出不是1 2 3，而是3 2 1.
func stackingDefers() { defer func() { fmt.Println(&amp;quot;1&amp;quot;) }() defer func() { fmt.Println(&amp;quot;2&amp;quot;) }() defer func() { fmt.</description>
    </item>
    
    <item>
      <title>通俗解释REST以及RESTful</title>
      <link>/blog/restful/</link>
      <pubDate>Tue, 18 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>/blog/restful/</guid>
      <description>看Url就知道要什么 看http method就知道干什么 看http status code就知道结果如何
 REST &amp;ndash; REpreseantational State Transfer @Ivony 老师的一句话很精辟： &amp;gt; URL定位资源，用HTTP动词（GET,POST,DELETE,DETC)描述操作
先说REST名称 REST &amp;ndash; REpresentational State Transfer首先，之所以晦涩是因为前面主语被去掉了，全称是 Resource Representational State Transfer：通俗来讲就是：资源在网络中以某种表现形式进行状态转移。分解开来：Resource：资源，即数据（前面说过网络的核心）。比如 newsfeed，friends等；Representational：某种表现形式，比如用JSON，XML，JPEG等；State Transfer：状态变化。通过HTTP动词实现。
REST的出处 Roy Fielding的毕业论文。这哥们参与设计HTTP协议，也是Apache Web Server项目（可惜现在已经是 nginx 的天下）的co-founder。PhD的毕业学校是 UC Irvine，Irvine在加州，有着充裕的阳光和美丽的海滩，是著名的富人区。Oculus VR 的总部就坐落于此（虚拟现实眼镜，被FB收购，CTO为Quake和Doom的作者 John Carmack）。
论文地址
为什么要使用RESTful结构 大家都知道&amp;rdquo;古代&amp;rdquo;网页是前端后端融在一起的，比如之前的PHP，JSP等。在之前的桌面时代问题不大，但是近年来移动互联网的发展，各种类型的Client层出不穷，RESTful可以通过一套统一的接口为 Web，iOS和Android提供服务。另外对于广大平台来说，比如Facebook platform，微博开放平台，微信公共平台等，它们不需要有显式的前端，只需要一套提供服务的接口，于是RESTful更是它们最好的选择。在RESTful架构下：
Server的API如何设计才满足RESTful要求?  URL root: https://example.org/api/v1/* https://api.example.com/v1/*
 API versioning: 可以放在URL里面，也可以用HTTP的header： /api/v1/
 URI使用名词而不是动词，且推荐用复数。
  BAD
 /getProducts /listOrders /retrieveClientByOrder?orderId=1  GOOD</description>
    </item>
    
    <item>
      <title>高次方程求解过程</title>
      <link>/blog/sqrtx/</link>
      <pubDate>Tue, 11 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>/blog/sqrtx/</guid>
      <description>高次方程没有通解，可以依靠牛顿迭代法来求解
 通俗易懂的学习牛顿迭代法</description>
    </item>
    
    <item>
      <title>文件操作_Golang</title>
      <link>/blog/fileoperator/</link>
      <pubDate>Thu, 06 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>/blog/fileoperator/</guid>
      <description>一般来说有四种常见的读取文件操作方法：
 使用File自带的Read方法 使用bufio库的Read方法 使用io/ioutil库的ReadAll() 使用io/ioutil库的ReadFile()  先说结论：
当每次读取块的大小小于4kb，建议使用bufio.NewReader(f),大于4kb用bufio.NewReaderSize(f,缓存大小)
要读Reader，图方便使用ioutil.ReadAll()
一次性读取文件，使用ioutil.ReadFile()
不建议使用普通的Read
关于性能的深入探究，我会在下篇博文详细探讨
总而言之，要性能使用bufio，方便就用ioutil
下面为各种方法示例
package main import ( &amp;quot;bufio&amp;quot; &amp;quot;fmt&amp;quot; &amp;quot;io&amp;quot; &amp;quot;io/ioutil&amp;quot; &amp;quot;os&amp;quot; ) type ValNode struct { row int col int val int } func main() { //1.创建一个原始数组 var chessMap [11][11]int chessMap[1][2] = 1 //黑子 chessMap[2][3] = 2 //篮子 //输出看看原始数组 for _, v := range chessMap { for _, v2 := range v { fmt.Printf(&amp;quot;%d\t&amp;quot;, v2) } } } //OS包 func read1(path string) { fi, err := os.</description>
    </item>
    
    <item>
      <title>取余与取模</title>
      <link>/blog/remdom/</link>
      <pubDate>Mon, 03 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>/blog/remdom/</guid>
      <description>大多数的golang资料的含糊不清一个知识点
在go语言圣经中，是这样说的
 算术运算符+、-、*和/可以适用于整数、浮点数和复数，但是取模运算符%仅用于整数间的运算。对于不同编程语言，%取模运算的行为可能并不相同。在Go语言中，%取模运算符的符号和被取模数的符号总是一致的，因此-5%3和-5%-3结果都是-2。除法运算符/的行为则依赖于操作数是否全为整数，比如5.0/4.0的结果是1.25，但是5/4的结果是1，因为整数除法会向着0方向截断余数。
 在教程中%又被称作为取余运算，其实取余与取模之间是有很大的区别的
对于整数 a，b 来说，取模运算或者求余运算的方法要分如下两步： 1、求整数商：c=a/b 2、计算模或者余数：r=a-(c*b) 求模运算和求余运算在第一步不同
取余运算在计算商值向0方向舍弃小数位
取模运算在计算商值向负无穷方向舍弃小数位
例如：4/(-3) 约等于 -1.3
在取余运算时候商值向 0 方向舍弃小数位为 -1
在取模运算时商值向负无穷方向舍弃小数位为-2
所以
4rem(-3)=1 4mod(-3)=-2</description>
    </item>
    
    <item>
      <title>Go的类型断言与使用</title>
      <link>/blog/go_type_assertion/</link>
      <pubDate>Wed, 29 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/blog/go_type_assertion/</guid>
      <description>类型断言解析 经常地我们对一个接口值的动态类型是不确定的，如方法的形参为接口类型时，此时就需要检验它是否符合我们需要的类型。 类型断言是一个使用在 接口值上 的操作。
断言类型的语法：x.(T) 这里x表示一个接口的类型，T表示一个类型（也可为接口类型）。 一个类型断言检查一个接口对象x的动态类型是否和断言的类型T匹配。
类型断言分两种情况： 第一种，如果断言的类型T是一个具体类型，类型断言x.(T)就检查x的动态类型是否和T的类型相同。
 如果这个检查成功了，类型断言的结果是一个类型为T的对象，该对象的值为接口变量x的动态值。换句话说，具体类型的类型断言从它的操作对象中获得具体的值。 如果检查失败，接下来这个操作会抛出panic，除非用两个变量来接收检查结果，如：f, ok := w.(*os.File)  第二种，如果断言的类型T是一个接口类型，类型断言x.(T)检查x的动态类型是否满足T接口。
 如果这个检查成功，则检查结果的接口值的动态类型和动态值不变，但是该接口值的类型被转换为接口类型T。换句话说，对一个接口类型的类型断言改变了类型的表述方式，改变了可以获取的方法集合（通常更大），但是它保护了接口值内部的动态类型和值的部分。 如果检查失败，接下来这个操作会抛出panic，除非用两个变量来接收检查结果，如：f, ok := w.(io.ReadWriter)  注意：
如果断言的操作对象x是一个nil接口值，那么不论被断言的类型T是什么这个类型断言都会失败。 我们几乎不需要对一个更少限制性的接口类型（更少的方法集合）做断言，因为它表现的就像赋值操作一样，除了对于nil接口值的情况。
//interface type Tester interface{ getName() string } type Teater2 interface{ printName() } //person类型 type Person struct{ name string } func (p Person)getName() string { return p.name } func (p Person) printName() { fmt.Println(p.name) } func main(){ var t Tester t=Person{&amp;quot;tmac&amp;quot;} check(t) } func check(t Tester) { //第一种情况 if f,ok1:=t.</description>
    </item>
    
    <item>
      <title>Struct In Golang</title>
      <link>/blog/structgo/</link>
      <pubDate>Tue, 28 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/blog/structgo/</guid>
      <description>结构体元素 结构体由关键字·结构体类型名称和具体对象构成，如下： 结构体初步认识 下面通过对比数组来了解一下结构体：
 从存储类型来看  数组只能存储相同的类型： s:=[]string{&amp;ldquo;a&amp;rdquo;, &amp;ldquo;b&amp;rdquo;, &amp;ldquo;c&amp;rdquo;, &amp;ldquo;d&amp;rdquo;, &amp;ldquo;e&amp;rdquo;} 结构体可以存储不同的类型
//声明结构体 type employee struct{ name,address string age int height,weight float64 }   从内存来看  他们都是在内存中占据连续的内存空间，但对于数组来说，每一个元素所占用的内存大小都是相同的，而结构体每一项所占用的内存大小不一定相同
 从类型组合角度看  数组没有组合的用法，例如一个一维数组，一旦数组类型确定就可以再把另一个一维数组设置为元素值，例如：
s := []string{&amp;ldquo;a&amp;rdquo;, &amp;ldquo;b&amp;rdquo;, &amp;ldquo;c&amp;rdquo;, &amp;ldquo;d&amp;rdquo;, &amp;ldquo;e&amp;rdquo;}
s[0] = []string{&amp;ldquo;f&amp;rdquo;, &amp;ldquo;g&amp;rdquo;}
此时运行该程序会出现类似此提示：cannot use []string literal (type []string) as type string in assignment;
结构体支持组合，我们知道一维空间是一条线，二维空间是一个平面，三维空间是一个空间
type line struct{ x int } type plane struct{ line y int } type space struct{ plane z int }  我们很自然地通过组合的方式，把一维扩张到二维，把二维扩张到三维，把三维扩张到四维，以此类推。。。。。</description>
    </item>
    
    <item>
      <title>成为动力的少，成为心结得多</title>
      <link>/blog/essay20190529/</link>
      <pubDate>Mon, 27 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/blog/essay20190529/</guid>
      <description></description>
    </item>
    
    <item>
      <title>优雅的多channel通信（GoLang)</title>
      <link>/blog/elegantchannel/</link>
      <pubDate>Fri, 19 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/blog/elegantchannel/</guid>
      <description>缘由 很早就听说了Golang的大名，只是远观（当时觉得太难了＝ ＝） 刚到公司的时候，研究过一段时间的coreos—-大部分都是Golang写的，还是觉得语法很啰嗦…… 几个月之前，老大就跟我谈过新系统可能用Golang来写，弥补我司只有Python这条技术线的弊端。 所以买了个视频学Golang，但是没有开始上手做东西，只是跟着教程了解了一些特性，然后就荒废了。
由于最近开始研究Python性能提升的可能，异步库gevent，直接的epoll，非拷贝的meoryview各种黑科技都用上，但是并发10K rps实在是没办法跨过的一道坎，索性，反正都是epoll/kevent，直接换Golang试试。
理解 后端开发，如果没有听过，Do not communicate by sharing memory; instead, share memory by communicating.那么你的地位可能就危险了。 前者需要考虑加锁避免race condition,加锁又会提高开发以及调试难度。而后者则可以将对共享memory的访问串行化，于是不用考虑race condition。
放例子 package main import &amp;quot;fmt&amp;quot; import &amp;quot;time&amp;quot; func fibonacci(c, quit chan int) { x, y := 1, 1 for { select { case c &amp;lt;- x: x, y = y, x+y case &amp;lt;- quit: fmt.Println(&amp;quot;quit&amp;quot;) return } } } func show(c, quit chan int) { for i := 0; i &amp;lt; 10; i ++ { fmt.</description>
    </item>
    
    <item>
      <title>JWT 授权验证</title>
      <link>/blog/jwt/</link>
      <pubDate>Thu, 28 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>/blog/jwt/</guid>
      <description>根 JWT通常由三部分组成: 头信息（header）, 消息体（payload）和签名（signature）。它是一种用于双方之间传递安全信息的表述性声明规范。
JWT作为一个开放的标准（RFC 7519），定义了一种简洁的、自包含的方法，从而使通信双方实现以JSON对象的形式安全的传递信息。
可以看出JWT并不是一种只能权限验证的工具，而是一种标准化的数据传输规范。
How to work?  客户端向授权服务系统发起请求，申请获取“令牌” 授权服务根据用户身份，生成一张专属的“令牌”，并将该“令牌”以JWT规范返回给客户端 客户端将获取到的“令牌”放到http请求的headers中后，向主服务器系统发起请求。主服务系统收到请求后会从headers中获取“令牌”，并从“令牌”中解析出该用户的身份权限，然后做相应的处理（同意或拒绝返回资源）  可以看出，JWT授权服务是可以脱离我们的主服务系统而作为一个独立系统存在的
What is token? JWT字符串 定义： 通过JWT规则加密后生成的字符串，三部分组成：Header，Payload，Signature。将这三部分由‘.’ 连接而组成的一长串加密字符串就成为JWT字符串。
Header 有且仅有两个数据组成，一个是“alg”（加密规范）指定了该JWT字符串的加密规则，另一个是“typ”（JWT字符串类型）。
例如：
{ &amp;quot;alg&amp;quot;: &amp;quot;HS256&amp;quot;, &amp;quot;typ&amp;quot;: &amp;quot;JWT&amp;quot; }  将这组JSON格式的数据通过Base64Url格式编码后，生成的字符串就是我们JWT字符串的第一部分。
Payload 由一组数据组成，它负责传输数据，我们可以添加一些已注册声明，比如“iss” （JWT字符串的颁发人名称），“exp” （该JWT字符串的过期时间），&amp;rdquo;sub&amp;rdquo; （身份），“aud” （受众），除了这些，我们还可以根据需要添自定义的需要传输数据，一般是发起请求的用户信息。例如：
{ “iss”:&amp;quot;RayPI&amp;quot;, &amp;quot;sub&amp;quot;: &amp;quot;Client&amp;quot;, &amp;quot;name&amp;quot;: &amp;quot;张三&amp;quot;, &amp;quot;uid&amp;quot;: 1 }  将该JSON格式的数据通过Base64Url格式编码后，生成的字符串就是我们JWT字符串的第二部分。
Signature 数字签名，由4个因素同时决定：编码后的header字符串，编码后的payload字符串，之前在头部声明的加密算法，我们定义的密匙字符串（secret）。</description>
    </item>
    
    <item>
      <title>Works</title>
      <link>/showcase/</link>
      <pubDate>Sat, 02 Feb 2019 11:34:00 +0100</pubDate>
      
      <guid>/showcase/</guid>
      <description>Projects Professional engineering project audit platform The main business includes the design, bidding, construction, settlement and other links in the construction project implementation quota design target calculation and verification, the amount of calculation, the bill of quantities, bidding control price preparation, measurement, settlement preparation and review, project settlement review and other cost consulting business. I was responsible for back-end API interface development. The project took three years,and it went public in Hong Kong Growing Enterprise Market , coded 836208.</description>
    </item>
    
    <item>
      <title>About</title>
      <link>/about/</link>
      <pubDate>Sat, 19 Jan 2019 02:42:30 +0100</pubDate>
      
      <guid>/about/</guid>
      <description>   Hi, I am Cosmo,a coder.      and      are my weapons.       Hi, I am Cosmo,a coder.      and      are my weapons.    -- -- </description>
    </item>
    
    <item>
      <title>如何清空一个分支</title>
      <link>/blog/gitdeletecommand/</link>
      <pubDate>Thu, 22 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>/blog/gitdeletecommand/</guid>
      <description>git删除单一文件或者文件夹容易操作，但对于一次删除多文件或者清空一个分支的过程代码如下：
# In the command-line, navigate to your local repository. # Ensure you are in the default branch: git checkout master # The rm -r command will recursively remove your folder: git rm -r folder-name # Commit the change: git commit -am &amp;quot;Remove duplicated directory&amp;quot; # Push the change to your remote repository: git push origin master  </description>
    </item>
    
    <item>
      <title>深入理解Context</title>
      <link>/blog/golangcontext/</link>
      <pubDate>Sun, 18 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>/blog/golangcontext/</guid>
      <description>控制并发有两种经典的方式，一种是WaitGroup，另一种就是Context。
什么是WaitGroup 它是一种控制并发的方式，它的这种控制并发的方式是控制多个goroutine同时完成。
func main() { var wg sync.WaitGroup wg.Add(2) go func() { time.Sleep(2*time.Second) fmt.Println(&amp;quot;1号完成&amp;quot;) wg.Done() }() go func() { time.Sleep(2*time.Second) fmt.Println(&amp;quot;2号完成&amp;quot;) wg.Done() }() wg.Wait() fmt.Println(&amp;quot;好了，大家都干完了，放工&amp;quot;) }  一个很简单的例子，一定要例子中的2个goroutine同时做完，才算是完成，先做好的就要等着其他未完成的，所有的goroutine要都全部完成才可以。
这是一种控制并发的方式，这种尤其适用于，好多个goroutine协同做一件事情的时候，因为每个goroutine做的都是这件事情的一部分，只有全部的goroutine都完成，这件事情才算是完成，这是等待的方式。
在实际的业务种，我们可能会有这么一种场景：需要我们主动的通知某一个goroutine结束。比如我们开启一个后台goroutine一直做事情，比如监控，现在不需要了，就需要通知这个监控goroutine结束，不然它会一直跑，就泄漏了。
chan通知 我们都知道一个goroutine启动后，我们是无法控制他的，大部分情况是等待它自己结束，那么如果这个goroutine是一个不会自己结束的后台goroutine呢？比如监控等，会一直运行的。
这种情况化，一直傻瓜式的办法是全局变量，其他地方通过修改这个变量完成结束通知，然后后台goroutine不停的检查这个变量，如果发现被通知关闭了，就自我结束。
这种方式也可以，但是首先我们要保证这个变量在多线程下的安全，基于此，有一种更好的方式：chan + select 。
func main() { stop := make(chan bool) go func() { for { select { case &amp;lt;-stop: fmt.Println(&amp;quot;监控退出，停止了...&amp;quot;) return default: fmt.Println(&amp;quot;goroutine监控中...&amp;quot;) time.Sleep(2 * time.Second) } } }() time.Sleep(10 * time.Second) fmt.Println(&amp;quot;可以了，通知监控停止&amp;quot;) stop&amp;lt;- true //为了检测监控过是否停止，如果没有监控输出，就表示停止了 time.</description>
    </item>
    
    <item>
      <title>JS 数据处理 - 对象和数组</title>
      <link>/blog/objects-and-arrays/</link>
      <pubDate>Sat, 28 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>/blog/objects-and-arrays/</guid>
      <description>《JS 数据处理 - 对象和数组》 对象 对象内容读取 如果属性键为字符串，且该字符串中只包含英文字母和下划线的话，可以直接用 &amp;lt;obj&amp;gt;.&amp;lt;key&amp;gt; 来读取属性值。
const essay = { title: &#39;基本数据处理 - 对象和数组&#39;, content: [&#39;对象&#39;, &#39;数组&#39;], from: { title: &#39;基本数据处理&#39;, author: { name: &#39;tmac&#39;, description: &#39;全栈开发&#39;, skill: [ &#39;Web 开发&#39;, &#39;移动端开发&#39;, &#39;小程序开发&#39; ] } }, } essay.title // 基本数据处理 - 对象和数组 essay.from.author.name // 阿梦  而当对象中所需要读取的目标属性键为数字、包含英文字母和下划线以外的字符串甚至是 Symbol 对象的时候，就需要使用 obj[key] 的形式来读取属性值了。
const obj = { 1: 2, &#39;a b c&#39;: &#39;d e f&#39;, [Symbol.for(&#39;foo&#39;)]: &#39;bar&#39; } obj[1] //=&amp;gt; 2 obj[&#39;a b c&#39;] //=&amp;gt; d e f obj[Symbol.</description>
    </item>
    
    <item>
      <title>判断点是否在多边形（Polygon）内部</title>
      <link>/blog/first-post-the-pledge/</link>
      <pubDate>Sat, 28 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>/blog/first-post-the-pledge/</guid>
      <description>判断点是否在多边形（Polygon）内部 如何判断 目前对于点在polygon内部的判断主流有两种方法：
 射线法，即以点开始做一射线，计算与多边形边界相交的次数。
 winding number，多边形围绕点的缠绕次数（原文：which counts the number of times the polygon winds around the point P. The point is outside only when this &amp;ldquo;winding number&amp;rdquo; wn = 0; otherwise, the point is inside.）
  今天，主要说说第一种射线法：
任一射线穿过多边形，奇数段位于多边形之内，偶数段位于多边形之外。
从该点出发沿着X轴画一条射线，依次判断该射线与每条边的交点，并统计交点个数，如果交点数为奇数，则在多边形内部（如图3个交点），如果焦点数是偶数，则在外部，射线法对凸和非凸多边形都适用，复杂度为O(N)，其它N是边数。
源码可参考
当多边形数目较少时，我们可以依次遍历每一个多边形（暴力遍历法），然后用射线法进行判断，这样效率也很高。而当多边形数目较多时，比如有10万个多边形，这个时候需要执行10万次射线法，响应时间达到3.9秒，这在互联网应用几乎不可忍受。下表是本人的简单测试，多边形边数均为7。
R树索引 暴力遍历法效率低下的原因是与每一个多边形都进行了射线法判断，如果能减少射线法的调用次数性能就能提升。因此我们的优化思路很直接，首先通过粗筛的方法快速找到符合条件的少量多边形，然后对粗筛后的多边形使用射线法判断，这样射线法的执行次数大大降低，效率也能大大提高。怎么粗筛呢？对于一维数据我们常常使用索引的方法，比如通过B树索引找到某一个范围区间段，然后对此范围区间段进行遍历查找，对于二维空间数据常常使用空间索引的方法，比如通过R树找到范围区间内的多边形，然后对此范围内的多边形进行精确判断，下面介绍最常使用的空间索引R树的解决思路。
 外包矩形表示多边形  由于多边形形状各异，我们需要以一种统一的方式来对多边形进行近似，最简单的方式就是用最小外包矩形来表示多边形。
 对最小外包矩形建立R树索引   查询   首先通过R树迅速判断用户所在位置（粗红点）是否被外包矩形覆盖（红色点代表用户所在位置；R树平均查询复杂度为O(Log(N))，N为多边形个数）； 如果不被任何外包矩形覆盖则返回不在地理围栏多边形内; 如果被外包矩形覆盖则还需要进一步判断是否在此外包矩形的多边形内部，采用上文提到的射线法判断  多边形边数较多怎么办 大多数应用的地理围栏多边形都比较简单，但有时也会遇到一些特别复杂的多边形，比如单个多边形的边数就超过十几万条，这时候对此复杂多边形执行一次射线法也非常耗时（因为射线法时间复杂度为O(N)，N为多边形边数）。
如何提高对复杂多边形执行射线法的计算效率呢？同样使用R树索引！笔者在实际应用中对边数较多（如超过1万）的多边形的边再单独进行R树索引，具体如图所示，首先对多边形的每条边构建最小外包矩形，然后在这些最小外包矩形基础上构建R树索引（R树索引上的外包矩形未画出），这样射线法求交点的时候首先通过R树判断射线是否与外包矩形相交，最后对R树粗筛后的边进行精确求交判断，时间复杂度从O(N)降到O(Log(N))，大大提高了计算效率。
实践 autocad有30多万个多边形，通过在内存中构建R树索引，使得线上实时地理围栏查询平均响应时间在1ms以内，而暴力查询响应时间是9秒左右。
相关源码 Python Java Javascript C#</description>
    </item>
    
    <item>
      <title>Golang中的init函数</title>
      <link>/blog/acknowledgefuncinit/</link>
      <pubDate>Mon, 18 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>/blog/acknowledgefuncinit/</guid>
      <description>本文主要解释go中的init函数的使用以及意义
init的几个特征  init 函数用于包的初始化，如初始化包中的变量，这个初始化在package xxx的时候完成，也就是在main之前完成。
 每个包可以拥有多个init函数，每个包的源文件也可以拥有多个init函数。
 同一个包中的init函数的执行顺序是没有明确定义的，但是不同包的init函数是根据包导入的依赖关系决定的。
 init函数不能被其他的函数调用，其实在main函数之前自动执行的。
  例子 1. 在main函数之前执行init package main import &amp;quot;fmt&amp;quot; func main() { fmt.Println(&amp;quot;do in main&amp;quot;) } func init() { fmt.Println(&amp;quot;do in init1&amp;quot;) } func init() { fmt.Println(&amp;quot;do in init2&amp;quot;) }  运行结果：
这个例子的运行结果说明：init函数在main函数之前执行，每个源文件中可以包含多个init函数。
2. init函数的执行顺序 现在我们init目录下的文件内容如下：
三个go程序代码分别如下所示：
// test.go package main import ( &amp;quot;fmt&amp;quot; _ &amp;quot;./level1&amp;quot; ) func main() { fmt.Println(&amp;quot;I am in main&amp;quot;) }  // level1.</description>
    </item>
    
    <item>
      <title>测试Travis CI</title>
      <link>/blog/testtrivis/</link>
      <pubDate>Tue, 01 Aug 2017 22:25:24 +0000</pubDate>
      
      <guid>/blog/testtrivis/</guid>
      <description></description>
    </item>
    
    <item>
      <title>一个早上</title>
      <link>/blog/essay-20170730/</link>
      <pubDate>Sun, 30 Jul 2017 23:25:24 +0000</pubDate>
      
      <guid>/blog/essay-20170730/</guid>
      <description>最近觉得自己挺懒的，注意力也不是特别的集中，梦想越来越近，还没付出过什么，似乎都是别人给的，周末的家中走来走去，女朋友去跳舞，我有处可去，但却哪都不想去，换了4，或者5本书，翻几页就摊开放着。按道理来说，我应该是如饥似渴的。 早上还在睡梦中的时候，就被电话吵醒，跟第一次飞到西安的大圣女友吃了碗马奎，我问他南方人应该都吃不惯这玩意，我早起也是从来不吃早餐，却总有一股饱腹感，他女友对我印象不好，我也没解释啥，想来也奇怪，我们大家都是一块长大的哥们，一起经历每一个男孩所经历过的所有阶段，一起有过无数不眠的夜晚，现在大家爱纷纷带来自己的女友，有人融入就得变得困难，我希望以后，我们还能一起在过年的高速上一路跑得快到黔东南，下一次逢7永远过不了的还会不会是黄。 回来时，忘了给女友带碗胡辣汤，是排队太困难了，我天生爱插队，偶尔心情不好的时候，还想体验逃单，去超市顺手喝完一瓶水，不愿意去结账，随手找个垃圾筐扔了，（以上情况，对情绪辅助有很好的作用，建议偶尔为之），但慢慢的，我连付钱时的单子多少都不愿意去看一眼。回到家，给女友热了个速冻包子，然后，我就接着玩我的树莓派，很出奇的不久后，女友做了一碗面，给我端了进来，我真的有点不敢相信自己的眼睛，我们认识快五年，他从来没有如此过。 舒服的生活，让人心安理得，但这个年纪心安理得后，却总有恐慌。
明年势必是兵荒马乱的一年。
{% note info %} 作者： 吴晓阳 {% endnote %}</description>
    </item>
    
    <item>
      <title>判断点是否在多边形（Polygon）内部</title>
      <link>/blog/gpucoding/</link>
      <pubDate>Thu, 27 Jul 2017 22:25:24 +0000</pubDate>
      
      <guid>/blog/gpucoding/</guid>
      <description>如何判断 目前对于点在polygon内部的判断主流有两种方法：
 射线法，即以点开始做一射线，计算与多边形边界相交的次数。
 winding number，多边形围绕点的缠绕次数（原文：which counts the number of times the polygon winds around the point P. The point is outside only when this &amp;ldquo;winding number&amp;rdquo; wn = 0; otherwise, the point is inside.）
  今天，主要说说第一种射线法：
任一射线穿过多边形，奇数段位于多边形之内，偶数段位于多边形之外。
从该点出发沿着X轴画一条射线，依次判断该射线与每条边的交点，并统计交点个数，如果交点数为奇数，则在多边形内部（如图3个交点），如果焦点数是偶数，则在外部，射线法对凸和非凸多边形都适用，复杂度为O(N)，其它N是边数。
源码可参考
当多边形数目较少时，我们可以依次遍历每一个多边形（暴力遍历法），然后用射线法进行判断，这样效率也很高。而当多边形数目较多时，比如有10万个多边形，这个时候需要执行10万次射线法，响应时间达到3.9秒，这在互联网应用几乎不可忍受。下表是本人的简单测试，多边形边数均为7。
R树索引 暴力遍历法效率低下的原因是与每一个多边形都进行了射线法判断，如果能减少射线法的调用次数性能就能提升。因此我们的优化思路很直接，首先通过粗筛的方法快速找到符合条件的少量多边形，然后对粗筛后的多边形使用射线法判断，这样射线法的执行次数大大降低，效率也能大大提高。怎么粗筛呢？对于一维数据我们常常使用索引的方法，比如通过B树索引找到某一个范围区间段，然后对此范围区间段进行遍历查找，对于二维空间数据常常使用空间索引的方法，比如通过R树找到范围区间内的多边形，然后对此范围内的多边形进行精确判断，下面介绍最常使用的空间索引R树的解决思路。
 外包矩形表示多边形  由于多边形形状各异，我们需要以一种统一的方式来对多边形进行近似，最简单的方式就是用最小外包矩形来表示多边形。
 对最小外包矩形建立R树索引   查询   首先通过R树迅速判断用户所在位置（粗红点）是否被外包矩形覆盖（红色点代表用户所在位置；R树平均查询复杂度为O(Log(N))，N为多边形个数）； 如果不被任何外包矩形覆盖则返回不在地理围栏多边形内; 如果被外包矩形覆盖则还需要进一步判断是否在此外包矩形的多边形内部，采用上文提到的射线法判断  多边形边数较多怎么办 大多数应用的地理围栏多边形都比较简单，但有时也会遇到一些特别复杂的多边形，比如单个多边形的边数就超过十几万条，这时候对此复杂多边形执行一次射线法也非常耗时（因为射线法时间复杂度为O(N)，N为多边形边数）。
如何提高对复杂多边形执行射线法的计算效率呢？同样使用R树索引！笔者在实际应用中对边数较多（如超过1万）的多边形的边再单独进行R树索引，具体如图所示，首先对多边形的每条边构建最小外包矩形，然后在这些最小外包矩形基础上构建R树索引（R树索引上的外包矩形未画出），这样射线法求交点的时候首先通过R树判断射线是否与外包矩形相交，最后对R树粗筛后的边进行精确求交判断，时间复杂度从O(N)降到O(Log(N))，大大提高了计算效率。
实践 autocad有30多万个多边形，通过在内存中构建R树索引，使得线上实时地理围栏查询平均响应时间在1ms以内，而暴力查询响应时间是9秒左右。
相关源码 Python Java Javascript C#</description>
    </item>
    
    <item>
      <title>In The End R.I.P</title>
      <link>/blog/rip/</link>
      <pubDate>Fri, 21 Jul 2017 12:25:24 +0000</pubDate>
      
      <guid>/blog/rip/</guid>
      <description> </description>
    </item>
    
    <item>
      <title>就日期为题</title>
      <link>/blog/essay-20170720/</link>
      <pubDate>Thu, 20 Jul 2017 23:25:24 +0000</pubDate>
      
      <guid>/blog/essay-20170720/</guid>
      <description>当追 有一天，我碰到一个腿长波大，肤白貌美，性温言善的妹子，隔了整整一排座位，刚好我们面对面，她可能没注意到我，我束起电话，透过俩张座位的缝隙去看她，她低着头，听着或许安静，或许应心的歌曲，很巧，风吹过，长发以微秒的姿势绕过脖颈，我看到了一道白皙的曲线，交接着美好的脸蛋。 没有人知道我是东亚国家的特务，动机只有一个，为了我的国家，据听说大洋国的特务，也来到这趟车中，我的目的就是截住他，让他避免跟下线接上头。任务对我来说已是轻车熟路。可此刻突然出现的妹子，让我这个寂寞的特务，想起自己无数个孤独的寒夜。我想跟我今后的日子同生同死，给我炉边灶台；一起做坐旋转木马，并肩看人间繁华的人来了，哈哈，终于来了。难免兴奋多想。思绪太远赶紧收回来。我还没有发现可疑的人员，去他妈的。我努力搜索，却又满心想她。列车提示广播想起美妙的歌曲。《梭罗河》。著名的俄罗斯名曲。美妙，给我中剑的心脏。正好推波助澜。“你的泉源来自梭罗，万水千山送你一同前往。”看看手表，我知道列车马上到站了。列车警务长悄悄送来一把枪。告诉我这个冲突起来更好应付。我说，呵呵，不用了，一个女特务，不必了。一个女特务而已。
放逐 配合所有的警务 还是没能发现任何线索，大洋国的保密工作就是不一般吧。没办法，迫于公众压力，只能放旅客先走了。哎，计划只能先搁置一步。懊恼至极，妹子擦身而过，急于走在前面，像一个水手，我从她的后脖颈能看出一种似乎久违了陆地的生梗。一瞬间的火焰，耀眼明媚。 我该说点什么或者做些什么，我被赋予了这项任务后，早就忘了，真情实感如何来表达，伪装的笑容，只让我作呕。可我对她认真的，党的教育可没告诉我，怎么做。妈的。 压抑住巨大的激素分泌，凭借着他的一点副作用，我又走上前去，对她说你知道吗？你像傍晚林中的小鹿。可我还没等到回答，一颗冰冷的枪管已经抵住我的身体，职业仪式告诉我，她已经知道我们彼此的身份。可我还是想告诉她，小鹿，不要害怕，猎人我会帮你干掉。 当偶然吃到了一颗花椒，心里不是骂娘，而是泛起了一阵感伤。这样的感伤是，我爱她，却不能跟她共赴极乐，因为我俩必须报效一个祖国。
形骸 故事到了最后，总要有个结局，给当事人一个交代，给大家一个说法。只是在某天，你无端想起一个人，她曾让你对明天有所期许，但是却完全没有出现在你的明天里 。 可见所有的悲剧之所以是悲剧，是因为他注定无法被成全。
对于我来说，没能在列车上将你控制，是我的失职。但却在你出站那刻将你俘获并说出想说的话。已是满足。所有的事情加个如果，便于假设。没有如果就是生活。 说到后来的日子，大抵我还是那个天冷下雨爱抱人，喝酒吃肉好约友，臧否人物乐读书，兴之所至，扯开衣裳走一个。相与枕藉被窝中，不知东方之既白。
{% note info %} 作者： 少年吴晓阳 {% endnote %}</description>
    </item>
    
    <item>
      <title>欧拉方程</title>
      <link>/blog/eulersequation/</link>
      <pubDate>Wed, 19 Jul 2017 01:25:24 +0000</pubDate>
      
      <guid>/blog/eulersequation/</guid>
      <description>欧拉方程的发现 首先，来看看该指数函数的泰勒级数表示，E 1 X和三角函数，正弦，的sin（x）余弦，COS（x）的。 比较cos（x）+ sin（x）用E 1 X。通知cos（x）+ sin（x）几乎与泰勒系列相同 E 1 X; 系列中的所有术语与标志完全相同。如你所知，指数函数E 1 X随着输入x的增长而呈指数增长。但是，这是什么指数函数具有周期性（振荡）函数来执行，COS（x）的和的sin（x）？
数学家们试图找出指数函数与2个振荡函数之和之间的奇怪关系。最后，Leonhard Euler完成了这个关系，将虚数，我进入上面的泰勒系列; E 1 {IX}而不是E 1 X而cos（x）+ isin（x）不是cos（x）+ sin（x）。
现在，我们找到E 1 {IX}等于cos（x）+ isin（x），这被称为欧拉方程。
欧拉方程图 我们知道指数函数E 1 X随x增长而呈指数增长。但是，这个功能是E 1 {IX}什么样的？
以下图像显示了复数指数函数的图复指数函数，e ^ {ix}，通过绘制E 1 {IX}3D复合空间（x-实 - 虚轴）中的泰勒级数。令人惊讶的是，它是螺旋弹簧（线圈）形状，围绕单位圆旋转。并且，当投影到实数（顶视图）和虚数轴（侧视图）时，它成为三角函数，分别是余弦和正弦。
图表
实数部分
虚数部分
复数指数函数的图形表示复指数函数，e ^ {ix}清楚地显示了与三角函数的关系; 实数的复指数函数，e ^ {ix}余数是余弦，虚部的复指数函数，e ^ {ix}正弦函数与二皮弧度的周期。
这是一个交互式OpenGL应用程序，用于绘制复指数函数，e ^ {ix}3D中的复数指数函数。
欧拉方程含义 当图形复指数函数，e ^ {ix}投影到复平面时，该功能复指数函数，e ^ {ix}在单位圆上进行跟踪。这是周期性的功能二皮。
这意味着提高数学常数，例如到虚数的幂九产生具有以弧度表示的角度x的复数。这种极性形式复指数函数，e ^ {ix}对于表示旋转对象或周期信号非常方便，因为它可以仅在单个术语而不是两个术语中表示复平面中的点a + ib。此外，它简化了在乘法中使用的数学，例如。
复杂的指数形式经常用于电气工程和物理学。例如，周期性信号可以表示傅立叶分析中的正弦和余弦函数的和，并且附加到弦的质量的运动也是正弦的。这些正弦函数可以用复数指数形式来代替，以便更简单的计算。
幅度（norm），| z | 的复数是一个标量值，可以通过使用指数和对数定律来重写：</description>
    </item>
    
    <item>
      <title>那双扶着我不跌倒的手</title>
      <link>/blog/time/</link>
      <pubDate>Tue, 18 Jul 2017 22:25:24 +0000</pubDate>
      
      <guid>/blog/time/</guid>
      <description></description>
    </item>
    
    <item>
      <title>改变 adaptive component 位置</title>
      <link>/blog/adaptionlocation/</link>
      <pubDate>Fri, 14 Jul 2017 06:25:24 +0000</pubDate>
      
      <guid>/blog/adaptionlocation/</guid>
      <description>情况 如果你想改变计划点参数，比如：Measurement Type,Chord Length,Measure Form,手动流程如下：
1.为每个参数创建每个点的用户参数 1.测量类型1 2.点位置1 3.测量类型2 4.点位置2 5.等等
2.使用API​​为每个家庭实例设置这些值
3.使用动态模型更新：
1.随时参考点参数变化，自动更新这些用户参数
2.在用户参数变化的任何时候自动更新参考点参数
代码执行 此代码执行上面列出的步骤2，步骤3。 您将注意到，“测量类型”内部存储为整数，我们需要将该整数转换为相应的字符串（Chord Length，Segment Length &amp;hellip;），以便我们可以从同名参数中获取长度值。
public void adapt() { Document doc = this.ActiveUIDocument.Document; using (Transaction t = new Transaction(doc,&amp;quot;Set Adapt Comp Data&amp;quot;)) { t.Start(); foreach (FamilyInstance fi in new FilteredElementCollector(doc).OfClass(typeof(FamilyInstance)).Cast&amp;lt;FamilyInstance&amp;gt;()) { int ctr = 1; foreach (ElementId pointId in AdaptiveComponentInstanceUtils.GetInstancePlacementPointElementRefIds(fi)) { ReferencePoint referencePoint = doc.GetElement(pointId) as ReferencePoint; Parameter measurementTypeParam = referencePoint.get_Parameter(&amp;quot;Measurement Type&amp;quot;); if (measurementTypeParam == null) continue; int i = measurementTypeParam.</description>
    </item>
    
    <item>
      <title>为什么是冈仁波切</title>
      <link>/blog/gangrenboqi/</link>
      <pubDate>Wed, 12 Jul 2017 21:25:24 +0000</pubDate>
      
      <guid>/blog/gangrenboqi/</guid>
      <description>人类对山的崇拜在世界各地分布广泛,但没有任何地方能像西藏这样登峰造极,放眼西藏，凡山皆有神,大到统领世界的四大神山、八大神山,小到掌管一地之部落神山,甚至个人之魂山,体系丰富、门类齐全、纷繁复杂,其中地位最崇高、影响最广泛的当属
冈仁波齐峰 在以高峻凌厉著称的极高山中,冈仁波齐显得殊为不同,即使冬季大雪覆盖绵延群峰,也非常容易辨识.
它山形独特,如同一座有着温柔曲线的金字塔,耸立在高原之上,恬澹从容、王者风范
南侧山体上一道道水平纹理岩层,构成了似乎可以直通天庭的阶梯,中间一条深深的纵向沟槽贯穿山体,冰雪造就的王冠坚实地嵌入雄浑的身躯,黑白相宜、错落有致，北侧则少有冰雪,整座山仿佛就是一块通体的圆滑岩石，当日月的光芒照射,山体漫射出柔软的红光,也颇为旖旎
为何成为第一神山？ 公元840年，吐蕃末代赞普朗达玛下令禁止佛教，推行西藏本地宗教“本教”，史称朗达玛灭佛，随即佛教僧侣反扑，刺杀赞普，四方骚然，天下大乱，西藏历史上最强大的王国分崩离析，从此陷入长达数百年的小邦混战，乱世之中曾经佛法昌盛的青藏高原万佛齐喑，僧侣们以佛法之名行淫欲杀戮、败坏佛教名誉，五世达赖喇嘛在评价这段历史时写道
（出自《西藏王臣记》）
▼
“（僧侣）持械杀人，恣意酒肉，纵情淫乐。论师们各从所好，自立宗规”
同时期的本教则蒸蒸日上，长此以往佛教必然被高原抛弃，更严重的是，青藏高原南北的佛陀之光都在逐渐黯淡，作为佛教发源地的印度，大部分佛教寺庙已经改宗印度教，远道而来的伊斯兰教则势头更甚，10世纪时巴基斯坦、印度北部等地的许多古国 相继转为清真之国，青高原以北中国新疆境内的诸佛国，也大部分被伊斯兰势力攻灭，佛教正受到内外南北各方的夹击，极有可能在印度、西藏同时灭亡
在朗达玛灭佛、天下大乱之时,偏远的冈仁波齐反而成了虔诚佛教徒的避难所,一支崇信佛教的吐蕃王室后裔,吉德尼玛衮王子,带着千余骑士来到冈仁波齐脚下的普兰县境内,之后逐步扩展到阿里全境,建立了西藏历史上著名的古格王国,古格王国遗址，位于今天札达县境内，距离冈仁波齐峰160公里,,古格王室力图复兴佛教,西藏、印度各地僧侣纷纷前来,其中最著名的是印度佛学中心超戒寺的住持,燃灯阿底峡尊者,为促成大师来到古格,当时的古格国王意希沃,被邻近的伊斯兰教国家噶尔洛俘获,噶尔洛要求意希沃或改信伊斯兰教,或用等身黄金来换得生机,意希沃却对带着黄金来赎他的人说
▼
“吾已年迈，不如用这些黄金迎请阿底峡大师”
阿底峡是藏传佛教史上影响最大的印度高僧之一,他的到来让衰败的佛教开始在冈仁波齐周边重兴,其次,偏远的冈仁波齐,是多个文明、宗教的圣地,在它周边东南西北四个方向,发育出了四条河流,它们或是雅鲁藏布江、印度河的正源,或是印度河、恒河的上游源头之一,这些河流所孕育的文明和宗教沿河上溯,均以冈仁波齐为精神之源
（发源于青藏高原的河流示意图；青藏高原是亚洲主要大河的发源地，我们熟知的三江源即位于青藏高原东部，而以冈仁波齐为中心则在青藏高原西部形成了一个鲜为人知的“准”三江源；之所以是“准”，是因为部分河流非正源；原图制作@Michael Buckley）
人们用四种天国神物命名这四条河流,即马、狮、象、孔雀,冈仁波齐以东为马泉河,是西藏的母亲河雅鲁藏布江的源头,冈仁波齐以南为孔雀河,为印度教的圣河恒河上游源头之一,孔雀河尽头的冈仁波齐峰,被古代印度人看作印度教法力最广大的湿婆神的居所,是世界轴心（Axis mundi）,另一个印度最古老的宗教耆那教则认为,冈仁波齐是创始人大雄的悟道之地
（印度教描绘的世界轴心，神和人之间以冈仁波齐为轴，分割出天地两个世界）
冈仁波齐以西为象泉河 其下游称为萨特莱杰河 是巴基斯坦主要河流印度河的支流
象泉河是阿里地区最重要的母亲河,古格王国，还有更早的象雄文明都在此孕育,西藏本土宗教本教,正是由象雄王子辛饶弥沃创立,冈仁波齐被认为是本教的起源地,也是本教360位神灵的居所,冈仁波齐以北为狮泉河,是印度河的正源,远古时期狮泉河的上源,还有着一个大型湖泊,位于今天冈仁波齐与纳木那尼之间,后来气候变迁、湖泊来水减少,不但与狮泉河中断连接,大湖也分裂为两个相对较小的湖泊,其中一湖便是玛旁雍错,面积330平方公里,湖面海拔4400米,是世界上海拔最高的淡水湖之一,湖水源于冈底斯山的冰雪,透明度高达14米,是中国透明度最高的湖泊,它与纳木错、羊卓雍错一起被称为,西藏三大圣湖
它的姊妹湖拉昂错是一个咸水湖,含盐量约是玛旁雍错的3倍,面积268.5 平方公里,比玛旁雍错略小,湖水呈深蓝色,湖滨几乎没有植物、没有牛羊,显得死气沉沉、没有生机,所以人称“鬼湖”
四条孕育出不同文明和宗教的河流,好像在冥冥中向世人昭示,冈仁波齐就是万水之源、世界中心,谁能据有冈仁波齐,谁就可以获得更多话语权,为争夺冈仁波齐,残酷的宗教冲突多次发生,在之后的流传中则演化为一场斗法
公元1093年 藏传佛教上师米拉日巴来到冈仁波齐修行,却被本教大师那若本琼阻止,那若本琼认为冈仁波齐是本教神山,禁止佛教徒在此修炼,于是二人约定以斗法论胜败,最先登上冈仁波齐山顶者为胜, 斗法开始时,那若本琼早早就冲向顶峰,米拉日巴则沉睡正酣、不急不忙,等到那若本琼快到山顶时,却发现米拉日巴早已端坐其上,惊得那若本琼直接从山顶滑落,并在冈仁波齐南坡留下了那一道明显的深槽, 在本教的起源地击败本教,佛教重新在青藏高原取得优势,圣湖玛旁雍错也正是在此时得名,其藏语意为“永恒不败的碧玉湖泊”,为巩固在冈仁波齐的胜利,藏传佛教吸收印度教中世界中心的说法,将冈仁波齐视为佛教经典中的须弥山, 它还吸纳了本教中的“卍”字,作为对冈仁波齐山体上的沟槽的解读,大量的高僧开始来到冈仁波齐修行,包括后来首开冈仁波齐转山路线的, 郭仓哇· 贡布多杰
（佛教的世界观：须弥山与四大部洲，绘图@Wikiwikiyarou）
最后,在冈仁波齐站稳脚根的藏传佛教,与西康等其它边缘地区保存的佛教种子一道,掀起了全藏的佛教复兴运动,佛教开始成为青藏高原上占据绝对优势的宗教,并向尼泊尔、不丹、蒙古高原、甘肃、云南等地传播,史称藏传佛教“后弘期”,而另一边,公元1203年,在经过十数次伊斯兰教入侵之后,印度超戒寺彻底被毁,佛教在印度正式宣告消亡
今天 原本水火不容的不同宗教,都可以在冈仁波齐面前和睦相处,不论国籍、文化、种族、教派,都可以在冈仁波齐向神灵致敬,冈仁波齐也成了一处世界上罕见的,跨宗教、跨文化、跨种族的神山
{% note info %} 转自：星球研究所 https://zhuanlan.zhihu.com/p/26986633 {% endnote %}</description>
    </item>
    
    <item>
      <title>齐次坐标</title>
      <link>/blog/homogeneoucoordinates/</link>
      <pubDate>Tue, 11 Jul 2017 01:25:24 +0000</pubDate>
      
      <guid>/blog/homogeneoucoordinates/</guid>
      <description> 问题 在几何空间中，同一平面上的两条平行线不能相交，或者不会相遇，这是大家都知道的一个常识。 但是，在投影空间中就有了另一种见解，例如，你站在铁轨的一头，向另一头望去，铁轨是越来越窄的，最后，两条平行的轨道在地平线相遇，这是一个无限远的点。 笛卡尔空间描述了我们的2D / 3D几何形状，但它们不足以处理投影空间（实际上，欧氏几何是投影几何的一个子集）。2D点的直角坐标可以表示为（x，y）。
如何理解无限远呢？
无限远点为（∞，∞）， 在欧几里德空间中变得毫无意义。平行线应该在投影空间无限远地满足，但在欧几里德空间中无法做到。数学家已经发现了一个解决这个问题的方法。
解决方案：齐次坐标 均匀坐标可以在投影空间中对图形和几何进行计算。均匀坐标是用N + 1数字表示N维坐标的方式。
为了使2D均匀坐标，我们只需在现有坐标中添加一个附加变量w即可。因此，在笛卡尔坐标（X，Y）中的点在均匀坐标中变为（x，y，w）。和X和Ÿ在笛卡尔与重新表示X，Y和W ^齐次的; X = x / w Y = y / w
例如，均匀的笛卡尔（1,2）中的点变为（1，2，1）。如果一点，（1，2）， 向无穷远移动，在笛卡尔坐标中变为（∞，∞）。由于（1/0，2/0）≈（∞，∞），在均匀坐标中变为（1，2，0）。注意，我们可以在无穷远的情况下表达点，而不使用“∞”。
为什么叫“齐次”？ 如前所述，为了将齐次坐标（x，y，w）转换为笛卡尔坐标，我们简单地将x和y除以w ;
将齐次转换为笛卡儿，我们可以找到一个重要的事实。我们来看下面的例子。
正如你所看到的，点（1,2,3），（2,4,6）和（4,8,12）对应于相同的欧几里德点（1/3,2/3）。任何标量积（1a，2a，3a）与欧几里德空间中的（1/3，2/3）相同。因此，这些点是“均匀的”，因为它们在欧氏空间（或笛卡尔空间）中代表相同的点。换句话说，齐次坐标是尺度不变量。
证明：两条平行线可以相交 考虑欧几里德空间是线性;
我们知道由于C≠D，上述方程式没有解决办法。 如果C = D，则两行相同（重叠）。
我们通过将x和y分别替换为x / w，y / w来重写投影空间的方程。
现在，我们有一个解（x，y，0），因为（C-D）w = 0，∴w = 0。因此，两个平行线在（x，y，0）处相交，这是无限远的点。
齐次坐标是计算机图形中非常有用和基本的概念，例如将3D场景投影到2D平面上。 </description>
    </item>
    
    <item>
      <title>开了挂的孙悟空</title>
      <link>/blog/npm/</link>
      <pubDate>Tue, 04 Jul 2017 22:25:24 +0000</pubDate>
      
      <guid>/blog/npm/</guid>
      <description></description>
    </item>
    
    <item>
      <title>逆矩阵(review)</title>
      <link>/blog/matrix-/</link>
      <pubDate>Mon, 03 Jul 2017 03:25:24 +0000</pubDate>
      
      <guid>/blog/matrix-/</guid>
      <description>内容 计算矩阵的逆矩阵意味着从矩阵首先得是一可逆矩阵（矩阵不一定是可逆的）。首先，为了可逆，矩阵必须是一个方形矩阵（它具有与列为例如2x2,3x3,4x4等一样多的行），并且矩阵的行列式必须不同于零。任何具有零行列式的矩阵都被称为是单数的（意味着它不是可逆的）。为了计算矩阵M的逆，我们将写入M，并且在其旁边写入单位矩阵（一个单位矩阵是一个方形矩阵，其中一个对角线和另一个零）。我们说，我们通过身份增加M。然后我们将减少这个增强（或相邻）的矩阵。
在开始之前，请记住矩阵可以被看作是可以使用所谓的行基本操作来解决的线性方程组。行基本操作具有保留由矩阵设置的解的属性。有三种这样的操作：您可以交换矩阵的行（操作1），将行的每个系数乘以非零常数（操作2），并将行自身与另一行的倍数替换为一行（操作3）。这些示例使用以下示例（行切换，行乘法和行相加）：
在第二个例子中，我们简单地将行1的所有系数乘以1/2，将行3的系数乘以2.在第三个例子中，我们将行1的系数加到行2的系数。 高斯法是使用这些基本行操作来将增强矩阵的左边内部的4×4矩阵变换为单位矩阵（我们说M是行减少）。通过对增强矩阵右侧的4x4单位矩阵执行相同的行操作，获得逆矩阵。
步骤1：设置行，使枢轴不同于零 使矩阵对角线的系数称为矩阵的枢轴。
如前所述，矩阵求逆过程的目标是使用行基本操作将每列的枢轴设置为1，将所有其他系数设置为0（在此过程结束时，我们将获得标识矩阵）。为了实现这一点，最好是从左边开始逐行排列。从左到右，保证当我们从列到列进行时，我们不会更改已经排列的列的值。
我们首先要检查当前列（正在处理的列）的枢轴系数的值。为了使我们的技术工作，这个值必须不等于零。如果它不同于零，那么我们可以直接转到第二步。如果它等于零，则我们需要在该列的矩阵中找到另一行，该列的值不等于零，并交换这两行（操作1）。但是，多于一行可能具有不同于零的值？那么我们应该选择哪一个？我们将拾取绝对值最高的行。
在右边的例子中，我们来看第二列的枢轴系数。因为该系数的值为零，所以我们用第二列的绝对值最大的行（在本例中为第3行）交换第2行。
我们使用高斯 - 约旦消除方法将原始矩阵转换为单位矩阵，同时在另一个矩阵（mat）上执行相同的操作，在矩阵的开始（第3行）被设置为身份矩阵（Matrix类构造函数默认将矩阵设置为单位矩阵）。在这个过程结束时，我们的原始矩阵用第二个矩阵的系数（最后的代码中的第39行）设置。如果我们找不到另一个值，那么这个矩阵不能被反转并且是奇异的（第11行）。
Matrix&amp;lt;T, N&amp;gt; &amp;amp; invert() { Matrix&amp;lt;T, N&amp;gt; mat; for (unsigned column = 0; column &amp;lt; N; ++column) { // Swap row in case our pivot point is not working if (m[column][column] == 0) { size_t big = column; for (unsigned row = 0; row &amp;lt; N; ++row) if (fabs(m[row][column]) &amp;gt; fabs(m[big][column])) big = row; // Print this is a singular matrix, return identity ?</description>
    </item>
    
    <item>
      <title>使用Revit和Dynamo进行火灾出口风险评估</title>
      <link>/blog/fireroad/</link>
      <pubDate>Mon, 10 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>/blog/fireroad/</guid>
      <description>情况 所使用的模型如下图所示。该脚本需要检测“正常”室出口门与地面4个“紧急出口”门之一之间的最短路线。因此，创建了该级别的房间计划，在这种情况下可以用作“循环”的房间以橙色表示。
结果 脚本的结果是创建每个房间出口到最近的紧急出口的撤离路线。在Dynamo这样看起来如下：
当使用Dynamo曲线创建他们的Revit细节线时，这将导致很好的撤离计划，如下图所示。
代码地址 https://autodesk.box.com/s/2q9z8ftqcu1uyj30rn9kh9a9n3l6ly1r</description>
    </item>
    
    <item>
      <title>面向对象的三大特性</title>
      <link>/blog/oopproperty/</link>
      <pubDate>Thu, 29 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>/blog/oopproperty/</guid>
      <description>封装 介绍 封装（encapsulation)就是把抽象出的字段与对字段的操作封装在一起，数据被保护在内部，程序的其他包只有通过被授权的操作（方法），才能对字段进行操作。
举例：对电视机的操作就是典型的封装
理解与优点  隐藏实现的细节 对数据进行验证，保证安全合理  如何体现封装  对结构体中的属性进行封装 通过方法，包，实现封装  封装的实现步骤  将结构体，字段（属性）的首字母小写（不能导出了，其他包不能使用，类似private） 给结构体所在的包提供一个工厂模式的函数，首字母大写。类似一个构造函数 提供一个首字母大写的Set方法（类似与其它语言的public），用于对属性判断并赋值  func(var 结构体类型名) SetXxx(参数列表) (返回值列表){ //加入数据验证的业务逻辑 var.字段=参数 }
 提供一个首字母大写的get方法（类似于其他语言的public），用于获取属性的值  func (var 结构体类型名) GetXxx() { return var.age; }
快速入门 案例：请大家看一个程序(person.go)，不能随便查看人的年龄，工资等隐私，并对输入的年龄进行合理验证。设计model包(person.go)main包(main.go 调用person结构体)
代码实现：
model/person.go
package model import &amp;quot;fmt&amp;quot; type person struct{ Name string age int //其他包不可以访问 sal float64 } //写一个工厂模式的函数，相当于构造函数 func NewPerson(name string) *person{ return &amp;amp;person{ Name:name, } } //为了访问age和sal我们编写一对SetXxx的方法和GetXxx的方法 func (p *person) SetAge(age int) { if age&amp;gt;0&amp;amp;&amp;amp;age&amp;lt;150{ p.</description>
    </item>
    
    <item>
      <title>如果西安的夜晚没有风</title>
      <link>/blog/essay-20160925/</link>
      <pubDate>Sun, 25 Sep 2016 23:25:24 +0000</pubDate>
      
      <guid>/blog/essay-20160925/</guid>
      <description>亲呀 咋 我最近搭了个网站 嗯？ 跟你约稿一篇，随便写，快快写，别忘了 关于啥？ 随便啊 多少字要求？ 没有，但也不要短到一句话 高中毕业之后，考试不在写作文开始，我就基本上没有写过任何东西。大学还写写日记，工作之后就一次也没有动过。突然朋友约我一篇稿，令我很是惶恐。其实最近特别想写点东西，可能因此就没有直接拒绝朋友。 我天生说话大舌头，思维逻辑也比较混乱，也不会编故事。我想如果写的话，还是写点自己亲身经历比较好点。
曾梦想仗剑走天涯 大学毕业期间，大家都在忙着找工作，我也投入到校招大军中。天性太懒，计算机专业学习了4年，唯一技能会用3种语言编写乘法口诀。对于工作，毫无想法，但又必须进行。那天早上，我12：00起床，去食堂吃了碗6块钱的肉炒拉条子盖个蛋，走出食堂，西安的太阳热的人沟渠子都是水，我突然想到我的人生应该有些改变。回宿舍换了拖鞋，穿上一个月前在网上买的西装，用舍友的洗面奶洗了个脸，镜中的我帅气非凡却略显陌生。 校招现场，我拿着简历，像一条猎狗一样，四处寻找礼物。最后做到一个漂亮的女应聘官面前。现在我回头来看，有时候一个很小的选择就能影响一个人的未来。 杭州的一家公司，需要长期出差。从小到大，最远去过西安，对于这样一个机会，觉得终于可以天高任鸟飞。我手上握了一把屠龙剑，而见不到任何一条龙。
25岁以后绝对不会给任何人打工 23岁那年，我暗恋了3年的高中班花，在和我在一起的一个月内，和另一个人劈腿。好哥们过来安慰我，我对天发誓：25岁以后绝对不给任何人打工。你帮我记下。我今年27岁，还在给别人打工，我亲呀早已经忘了我说过的那句话，我记得很清，从25岁到27岁我换了3家公司，从2000工资涨到20000工资，从小张-张店长-张经理-张老师。职位与工资的改变对我唯一不同的是：一个月300元烟钱变成了500元；维信好友100个变成了500个；领导从李总变成了何总。
你为什么不努力？因为我懒啊 大学是我人生中最美好的时光，我有了爱情。从大学至今，我总共谈了6个对象，对每个人我都认为这个女娃我要和她走一生，到今天我单身。我这个人对爱情一直以来比较向往，但爱情周期都不长。前5个女友时间最长的3个月，第6个破天荒地谈了3年，情感方面的磨难我都扛住了，但最后却败给了狗日的现实。我就说嘛，上帝打开了一扇门，绝对会关上一扇窗，要不然容易漏风。 所谓的败给现实，其实还是自己不够努力，我知道最好的情况是：化悲伤为动力。可是我这个人太懒了，现实是要挑战的，但是先让我睡够。我谁都不怪，我自己太懒。
明年的目标在西安买套房 16年底，我给自己定下了人生中第一个目标：西安买套房。我一年收入15万，贷款15万，再借10万，西安首付没有问题。3-4月份，西安房价平均上涨1000元，到如今已经上涨2000，现在觉得买房的事情不用急，我还年轻，不急不急。
走的时间越长，越难回来 我现在最开心的时候，就是回家的时候。人生就行围城：城里的人想出去，城外的人想进来。 我大学最好的室友，放弃了西安一个月10000左右的收入，去了北京，说是趁着年轻出去闯闯。约我稿的亲呀，计划明年去新西兰，哥哥在河南，大伟在山区。他们问我啥时候回来，我说就这几年，总是要定下来。 4月份去天津面试新工作，面试官问我，这份工作需要定在天津，你可以接受吗？没问题。
我站在这繁华的街上，找不到该去的方向 在外漂泊4年，早已不再是当年的自己。人都会成长，每个人会根据经历不同，形成不同的待人接物。我用了4年时间，不断打磨我自己，到现在有了大概轮廓。可我也不知道，这几年为了成长我所改变的一些东西，是否值得。我遇事沉稳，却缺乏激情；左右逢源，却处处防备；谈吐幽默，却毫无乐趣。在外面开阔了眼界，遇到形形色色的人，碰见许许多多的事，听过数不清的人生格言，鸡汤都他妈的把我从120养到了160；、可是到今天，我对自己的人生越来越没有想法，一切都是被生活推着向前走，我觉得我需要改变，可我又不知道从何开始。我现在感受，我知道我要做什么，但我不知道的是：我为了什么去做。 一切回到刚开始：大学那天吃完那碗肉炒拉条子盖蛋之后，走出食堂，阳光明媚，我看到一个漂亮的女娃上了一辆宝马。
{% blockquote [author] %} 张大圣 {% endblockquote %}</description>
    </item>
    
    <item>
      <title>GO break&amp;continue</title>
      <link>/blog/breakcontinue/</link>
      <pubDate>Sat, 28 May 2016 00:00:00 +0000</pubDate>
      
      <guid>/blog/breakcontinue/</guid>
      <description>break 利用break 可以提前退出循环，break 终止当前的循环；也可以定义标签，break指定的循环体。
break的用法示例1：
package main import ( &amp;quot;fmt&amp;quot; ) func main() { for i := 0; i &amp;lt; 10; i++ { if i &amp;gt; 5 { break //终止这个循环，只打印0到5 } fmt.Println(i) } }  输出结果：
0 1 2 3 4 5  break的用法示例2：
循环嵌套循环时，可以在break 后指定标签。用标签决定哪个循环被终止
package main import ( &amp;quot;fmt&amp;quot; ) func main() { J: for j := 0; j &amp;lt; 5; j++ { for i := 0; i &amp;lt; 10; i++ { if i &amp;gt; 6 { break J //现在终止的是j 循环，而不是i的那个 } fmt.</description>
    </item>
    
    <item>
      <title>Multidimensional Array</title>
      <link>/blog/matrix_go/</link>
      <pubDate>Tue, 29 Dec 2015 00:00:00 +0000</pubDate>
      
      <guid>/blog/matrix_go/</guid>
      <description>简介 Go 语言支持多维数组，以下为常用的多维数组声明方式：
var variable_name [SIZE1][SIZE2]...[SIZEN] variable_type  以下实例声明了三维的整型数组：
var threedim [5][10][4]int  二维数组 二维数组是最简单的多维数组，二维数组本质上是由一维数组组成的。二维数组定义方式如下：
var arrayName [ x ][ y ] variable_type  variable_type 为 Go 语言的数据类型，arrayName 为数组名，二维数组可认为是一个表格，x 为行，y 为列，下图演示了一个二维数组 a 为三行四列：
二维数组中的元素可通过 a[ i ][ j ] 来访问。
传统意义上的静态二维数组，声明方式和一维数组一样
array := [2][3]int{{1, 2, 3}, {4, 5, 6}} for i := range array { for j := range array[i] { fmt.Printf(&amp;quot;%v &amp;quot;, array[i][j]) } fmt.Println() }  输出：</description>
    </item>
    
    <item>
      <title>循环队列</title>
      <link>/blog/queuearry/</link>
      <pubDate>Wed, 03 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>/blog/queuearry/</guid>
      <description>对于一般队列到达尾部又向前存储的队列称为循环队列，为了避免假溢出，我们通常采用循环队列。
循环队列无论入队还是出队，队尾，队头加1后都要取模运算，例如入队后队尾后移一位：Q.rear =(Q.rear+1)%Maxsize。
为什么要%MaxSize呢？ 主要是为了处理临界状态，即Q.rear向后移动一个位置Q.rear+1后，很有可能超出了数组的下标，这时它的下一个位置其实是0，如果将一维数组画成环形图，如图所示：
上图中最大空间Maxsize，当Q.rear=Maxsize-1时，(Q.rear+1)%Maxsize=0，而且Q.front=0，正好满足队满的条件：(Q.rear+1) %Maxsize= Q.front，此时为队满。因此无论是front还是rear向后移动一个位置时，都要加1与最大空间Maxsize取模运算，处理临界问题。
总结 队空：Q.front=Q.rear; // Q.rear和Q.front指向同一个位置
队满： (Q.rear+1) %Maxsize=Q.front; // Q.rear向后移一位正好是Q.front
入队： Q.base[Q.rear]=x; //将元素放入Q.rear所指空间， Q.rear =( Q.rear+1) %Maxsize; // Q.rear向后移一位
出队： e= Q.base[Q.front]; //用变量记录Q.front所指元素， Q.front=(Q.front+1) %Maxsize // Q. front向后移一位
循环队列中到底存了多少个元素呢？ 因为队列是循环的，所以存在两种情况：
（1）Q.rear&amp;gt;= Q.front，如下图所示：
这种情况队列中元素个数为：Q.rear-Q.front=4-1=3。
（2）Q.rear&amp;lt; Q.front，如下图所示：
此时，Q.rear=4，Q.front=Maxsize-2，Q.rear-Q.front=6-Maxsize。但是我们可以看到循环队列中的元素实际上为6个，那怎么办呢？当两者之差为负数时，可以将差值+Maxsize计算元素个数，即：Q.rear-Q.front+Maxsize=6-Maxsize+Maxsize =6，元素个数为6。
那么在计算元素个数时，可以分两种情况判断： Q.rear&amp;gt;= Q.front：元素个数为Q.rear-Q.front； Q.rear&amp;lt;Q.front：元素个数为Q.rear-Q.front+ Maxsize；
也可以采用取模的方法把两种情况统一为一个语句：
队列中元素个数：(Q.rear-Q.front+Maxsize)% Maxsize
当Q.rear-Q.front为负数时，加上Maxsize再取余正好是元素个数，如(-2+6)%6=4；当Q.rear-Q.front为正数时，加上Maxsize超过了最大空间数，取余后正好是元素个数，如(3+6)%6=3。</description>
    </item>
    
    <item>
      <title>Go interface summary</title>
      <link>/blog/interfacesummary/</link>
      <pubDate>Fri, 29 May 2015 00:00:00 +0000</pubDate>
      
      <guid>/blog/interfacesummary/</guid>
      <description> what&amp;rsquo;s the interface 什么是接口
 接口类型是一种抽象的类型，它描述了一系列方法的集合。 接口约定：接口类型中定义的方法即为约定，若一个具体类型实现了所有这些方法，则该类型就满足该接口的约定，或者说它是这个接口类型的实例（实现了该接口）。 可替换性(LSP里氏替换)：满足相同接口约定的类型之间可进行相互替换。例如：若一个方法的形参定义为接口类型，那么它可以接收任何满足该接口约定的类型的实参。 接口内嵌：接口类型可通过组合已有的接口来定义 io.Writer接口提供了所有的类型写入bytes的抽象，包括文件类型，内存缓冲区，网络链接，HTTP客户端，压缩工具，哈希等等；io.Reader可以代表任意可以读取bytes的类型，io.Closer可以是任意可以关闭的值，例如一个文件或是网络链接。还有fmt.Stringer接口等 接口类型名一般以“er”结尾  what&amp;rsquo;s the interface value 什么是接口值
 接口值：即接口变量的值，由两个部分组成，一个具体的类型和那个类型的值。它们被称为接口的动态类型和动态值 接口值的零值：动态类型type和对应的动态值value均为nil，如var w io.Writer 空接口值：当且仅当接口的动态类型type和对应的动态值value均为nil时，才为空接口值，此时它等于nil 接口变量的赋值与调用过程：  如w = os.Stdout，这个赋值过程调用了一个具体类型到接口类型的隐式转换，这和显式的使用io.Writer(os.Stdout)是等价的。这个接口值w的动态类型被设为*os.Stdout指针的类型描述符，它的动态值持有os.Stdout的拷贝 调用一个包含*os.File类型指针的接口值的Write方法，w.Write([]byte(&amp;ldquo;hello&amp;rdquo;)) ，使得(*os.File).Write方法被调用  一个接口值可以持有任意大的动态值，不论动态值多大，接口值总是可以容下它 接口值的可比较性：  时刻记住：只能比较动态类型是可比较类型的接口值。 如果接口值的动态类型是可比较的，那么它们之间就可以使用==和!=来进行比较：两个接口值相等仅当它们都是nil值或者它们的动态类型相同并且动态值也根据这个动态类型的==操作相等。 如果接口值是可比较的，那么它们可以用在map的键或者作为switch语句的操作数 非接口类型要么是安全的可比较类型（如基本类型和指针）要么是完全不可比较的类型（如切片，映射类型，和函数），但是在比较接口值或者包含了接口值的聚合类型时，我们必须要意识到潜在的panic。同样的风险也存在于使用接口作为map的键或者switch的操作数。  注意：一个包含nil指针的接口不是nil接口（空接口），此时调用接口方法会发生panic错误。即一个接口值的动态类型type != nil，但动态值value == nil，此时的接口值 w != nil。（当把一个值为nil的非接口类型的变量转换为接口类型时，即出现这种情况） 技巧：使用接口时，直接声明一个接口类型的变量，然后再对它赋值，之后使用该变量时，就可以直接把它和nil比较来判断是否为空接口  </description>
    </item>
    
    <item>
      <title></title>
      <link>/iclj/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/iclj/</guid>
      <description>Professional Development Personal and Professional Learning Goals a Backend development scientist
How to get there? Reflective Learning something specific in the first semester Teamwork and management In project management course, Our team needs to incubate an innovation project, the electronic specification project.I think it will be easy because it is our strong point. But I found myself overly optimistic until the teacher asked me to submit the first version of the document.</description>
    </item>
    
  </channel>
</rss>